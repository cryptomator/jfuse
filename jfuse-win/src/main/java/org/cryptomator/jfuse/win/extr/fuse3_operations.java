// Generated by jextract

package org.cryptomator.jfuse.win.extr;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.lang.foreign.*;

public class fuse3_operations {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("getattr"),
        Constants$root.C_POINTER$LAYOUT.withName("readlink"),
        Constants$root.C_POINTER$LAYOUT.withName("mknod"),
        Constants$root.C_POINTER$LAYOUT.withName("mkdir"),
        Constants$root.C_POINTER$LAYOUT.withName("unlink"),
        Constants$root.C_POINTER$LAYOUT.withName("rmdir"),
        Constants$root.C_POINTER$LAYOUT.withName("symlink"),
        Constants$root.C_POINTER$LAYOUT.withName("rename"),
        Constants$root.C_POINTER$LAYOUT.withName("link"),
        Constants$root.C_POINTER$LAYOUT.withName("chmod"),
        Constants$root.C_POINTER$LAYOUT.withName("chown"),
        Constants$root.C_POINTER$LAYOUT.withName("truncate"),
        Constants$root.C_POINTER$LAYOUT.withName("open"),
        Constants$root.C_POINTER$LAYOUT.withName("read"),
        Constants$root.C_POINTER$LAYOUT.withName("write"),
        Constants$root.C_POINTER$LAYOUT.withName("statfs"),
        Constants$root.C_POINTER$LAYOUT.withName("flush"),
        Constants$root.C_POINTER$LAYOUT.withName("release"),
        Constants$root.C_POINTER$LAYOUT.withName("fsync"),
        Constants$root.C_POINTER$LAYOUT.withName("setxattr"),
        Constants$root.C_POINTER$LAYOUT.withName("getxattr"),
        Constants$root.C_POINTER$LAYOUT.withName("listxattr"),
        Constants$root.C_POINTER$LAYOUT.withName("removexattr"),
        Constants$root.C_POINTER$LAYOUT.withName("opendir"),
        Constants$root.C_POINTER$LAYOUT.withName("readdir"),
        Constants$root.C_POINTER$LAYOUT.withName("releasedir"),
        Constants$root.C_POINTER$LAYOUT.withName("fsyncdir"),
        Constants$root.C_POINTER$LAYOUT.withName("init"),
        Constants$root.C_POINTER$LAYOUT.withName("destroy"),
        Constants$root.C_POINTER$LAYOUT.withName("access"),
        Constants$root.C_POINTER$LAYOUT.withName("create"),
        Constants$root.C_POINTER$LAYOUT.withName("lock"),
        Constants$root.C_POINTER$LAYOUT.withName("utimens"),
        Constants$root.C_POINTER$LAYOUT.withName("bmap"),
        Constants$root.C_POINTER$LAYOUT.withName("ioctl"),
        Constants$root.C_POINTER$LAYOUT.withName("poll"),
        Constants$root.C_POINTER$LAYOUT.withName("write_buf"),
        Constants$root.C_POINTER$LAYOUT.withName("read_buf"),
        Constants$root.C_POINTER$LAYOUT.withName("flock"),
        Constants$root.C_POINTER$LAYOUT.withName("fallocate")
    ).withName("fuse3_operations");
    public static MemoryLayout $LAYOUT() {
        return fuse3_operations.$struct$LAYOUT;
    }
    static final FunctionDescriptor getattr$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle getattr$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.getattr$FUNC
    );
    public interface getattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(getattr fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(getattr.class, fi, fuse3_operations.getattr$FUNC, scope);
        }
        static getattr ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse3_operations.getattr$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, (java.lang.foreign.MemorySegment)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle getattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("getattr"));
    public static VarHandle getattr$VH() {
        return fuse3_operations.getattr$VH;
    }
    public static MemorySegment getattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.getattr$VH.get(seg);
    }
    public static void getattr$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.getattr$VH.set(seg, x);
    }
    public static MemorySegment getattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.getattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void getattr$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.getattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static getattr getattr (MemorySegment segment, SegmentScope scope) {
        return getattr.ofAddress(getattr$get(segment), scope);
    }
    static final FunctionDescriptor readlink$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle readlink$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.readlink$FUNC
    );
    public interface readlink {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2);
        static MemorySegment allocate(readlink fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(readlink.class, fi, fuse3_operations.readlink$FUNC, scope);
        }
        static readlink ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2) -> {
                try {
                    return (int)fuse3_operations.readlink$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle readlink$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("readlink"));
    public static VarHandle readlink$VH() {
        return fuse3_operations.readlink$VH;
    }
    public static MemorySegment readlink$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.readlink$VH.get(seg);
    }
    public static void readlink$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.readlink$VH.set(seg, x);
    }
    public static MemorySegment readlink$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.readlink$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void readlink$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.readlink$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static readlink readlink (MemorySegment segment, SegmentScope scope) {
        return readlink.ofAddress(readlink$get(segment), scope);
    }
    static final FunctionDescriptor mknod$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle mknod$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.mknod$FUNC
    );
    public interface mknod {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, int _x2);
        static MemorySegment allocate(mknod fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(mknod.class, fi, fuse3_operations.mknod$FUNC, scope);
        }
        static mknod ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, int __x2) -> {
                try {
                    return (int)fuse3_operations.mknod$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mknod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("mknod"));
    public static VarHandle mknod$VH() {
        return fuse3_operations.mknod$VH;
    }
    public static MemorySegment mknod$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.mknod$VH.get(seg);
    }
    public static void mknod$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.mknod$VH.set(seg, x);
    }
    public static MemorySegment mknod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.mknod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mknod$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.mknod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mknod mknod (MemorySegment segment, SegmentScope scope) {
        return mknod.ofAddress(mknod$get(segment), scope);
    }
    static final FunctionDescriptor mkdir$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle mkdir$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.mkdir$FUNC
    );
    public interface mkdir {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1);
        static MemorySegment allocate(mkdir fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(mkdir.class, fi, fuse3_operations.mkdir$FUNC, scope);
        }
        static mkdir ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1) -> {
                try {
                    return (int)fuse3_operations.mkdir$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mkdir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("mkdir"));
    public static VarHandle mkdir$VH() {
        return fuse3_operations.mkdir$VH;
    }
    public static MemorySegment mkdir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.mkdir$VH.get(seg);
    }
    public static void mkdir$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.mkdir$VH.set(seg, x);
    }
    public static MemorySegment mkdir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.mkdir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mkdir$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.mkdir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mkdir mkdir (MemorySegment segment, SegmentScope scope) {
        return mkdir.ofAddress(mkdir$get(segment), scope);
    }
    static final FunctionDescriptor unlink$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle unlink$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.unlink$FUNC
    );
    public interface unlink {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(unlink fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(unlink.class, fi, fuse3_operations.unlink$FUNC, scope);
        }
        static unlink ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)fuse3_operations.unlink$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle unlink$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("unlink"));
    public static VarHandle unlink$VH() {
        return fuse3_operations.unlink$VH;
    }
    public static MemorySegment unlink$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.unlink$VH.get(seg);
    }
    public static void unlink$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.unlink$VH.set(seg, x);
    }
    public static MemorySegment unlink$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.unlink$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void unlink$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.unlink$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static unlink unlink (MemorySegment segment, SegmentScope scope) {
        return unlink.ofAddress(unlink$get(segment), scope);
    }
    static final FunctionDescriptor rmdir$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle rmdir$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.rmdir$FUNC
    );
    public interface rmdir {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(rmdir fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(rmdir.class, fi, fuse3_operations.rmdir$FUNC, scope);
        }
        static rmdir ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)fuse3_operations.rmdir$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle rmdir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("rmdir"));
    public static VarHandle rmdir$VH() {
        return fuse3_operations.rmdir$VH;
    }
    public static MemorySegment rmdir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.rmdir$VH.get(seg);
    }
    public static void rmdir$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.rmdir$VH.set(seg, x);
    }
    public static MemorySegment rmdir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.rmdir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void rmdir$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.rmdir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static rmdir rmdir (MemorySegment segment, SegmentScope scope) {
        return rmdir.ofAddress(rmdir$get(segment), scope);
    }
    static final FunctionDescriptor symlink$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle symlink$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.symlink$FUNC
    );
    public interface symlink {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(symlink fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(symlink.class, fi, fuse3_operations.symlink$FUNC, scope);
        }
        static symlink ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse3_operations.symlink$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle symlink$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("symlink"));
    public static VarHandle symlink$VH() {
        return fuse3_operations.symlink$VH;
    }
    public static MemorySegment symlink$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.symlink$VH.get(seg);
    }
    public static void symlink$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.symlink$VH.set(seg, x);
    }
    public static MemorySegment symlink$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.symlink$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void symlink$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.symlink$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static symlink symlink (MemorySegment segment, SegmentScope scope) {
        return symlink.ofAddress(symlink$get(segment), scope);
    }
    static final FunctionDescriptor rename$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle rename$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.rename$FUNC
    );
    public interface rename {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, int _x2);
        static MemorySegment allocate(rename fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(rename.class, fi, fuse3_operations.rename$FUNC, scope);
        }
        static rename ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, int __x2) -> {
                try {
                    return (int)fuse3_operations.rename$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle rename$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("rename"));
    public static VarHandle rename$VH() {
        return fuse3_operations.rename$VH;
    }
    public static MemorySegment rename$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.rename$VH.get(seg);
    }
    public static void rename$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.rename$VH.set(seg, x);
    }
    public static MemorySegment rename$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.rename$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void rename$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.rename$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static rename rename (MemorySegment segment, SegmentScope scope) {
        return rename.ofAddress(rename$get(segment), scope);
    }
    static final FunctionDescriptor link$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle link$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.link$FUNC
    );
    public interface link {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(link fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(link.class, fi, fuse3_operations.link$FUNC, scope);
        }
        static link ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse3_operations.link$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle link$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("link"));
    public static VarHandle link$VH() {
        return fuse3_operations.link$VH;
    }
    public static MemorySegment link$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.link$VH.get(seg);
    }
    public static void link$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.link$VH.set(seg, x);
    }
    public static MemorySegment link$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.link$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void link$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.link$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static link link (MemorySegment segment, SegmentScope scope) {
        return link.ofAddress(link$get(segment), scope);
    }
    static final FunctionDescriptor chmod$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle chmod$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.chmod$FUNC
    );
    public interface chmod {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(chmod fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(chmod.class, fi, fuse3_operations.chmod$FUNC, scope);
        }
        static chmod ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse3_operations.chmod$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, __x1, (java.lang.foreign.MemorySegment)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle chmod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("chmod"));
    public static VarHandle chmod$VH() {
        return fuse3_operations.chmod$VH;
    }
    public static MemorySegment chmod$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.chmod$VH.get(seg);
    }
    public static void chmod$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.chmod$VH.set(seg, x);
    }
    public static MemorySegment chmod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.chmod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void chmod$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.chmod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static chmod chmod (MemorySegment segment, SegmentScope scope) {
        return chmod.ofAddress(chmod$get(segment), scope);
    }
    static final FunctionDescriptor chown$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle chown$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.chown$FUNC
    );
    public interface chown {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, int _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(chown fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(chown.class, fi, fuse3_operations.chown$FUNC, scope);
        }
        static chown ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, int __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    return (int)fuse3_operations.chown$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, __x1, __x2, (java.lang.foreign.MemorySegment)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle chown$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("chown"));
    public static VarHandle chown$VH() {
        return fuse3_operations.chown$VH;
    }
    public static MemorySegment chown$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.chown$VH.get(seg);
    }
    public static void chown$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.chown$VH.set(seg, x);
    }
    public static MemorySegment chown$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.chown$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void chown$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.chown$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static chown chown (MemorySegment segment, SegmentScope scope) {
        return chown.ofAddress(chown$get(segment), scope);
    }
    static final FunctionDescriptor truncate$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle truncate$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.truncate$FUNC
    );
    public interface truncate {

        int apply(java.lang.foreign.MemorySegment _x0, long _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(truncate fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(truncate.class, fi, fuse3_operations.truncate$FUNC, scope);
        }
        static truncate ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, long __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse3_operations.truncate$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, __x1, (java.lang.foreign.MemorySegment)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle truncate$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("truncate"));
    public static VarHandle truncate$VH() {
        return fuse3_operations.truncate$VH;
    }
    public static MemorySegment truncate$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.truncate$VH.get(seg);
    }
    public static void truncate$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.truncate$VH.set(seg, x);
    }
    public static MemorySegment truncate$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.truncate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void truncate$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.truncate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static truncate truncate (MemorySegment segment, SegmentScope scope) {
        return truncate.ofAddress(truncate$get(segment), scope);
    }
    static final FunctionDescriptor open$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle open$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.open$FUNC
    );
    public interface open {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(open fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(open.class, fi, fuse3_operations.open$FUNC, scope);
        }
        static open ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse3_operations.open$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle open$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("open"));
    public static VarHandle open$VH() {
        return fuse3_operations.open$VH;
    }
    public static MemorySegment open$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.open$VH.get(seg);
    }
    public static void open$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.open$VH.set(seg, x);
    }
    public static MemorySegment open$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.open$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void open$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.open$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static open open (MemorySegment segment, SegmentScope scope) {
        return open.ofAddress(open$get(segment), scope);
    }
    static final FunctionDescriptor read$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle read$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.read$FUNC
    );
    public interface read {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2, long _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(read fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(read.class, fi, fuse3_operations.read$FUNC, scope);
        }
        static read ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2, long __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)fuse3_operations.read$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, __x2, __x3, (java.lang.foreign.MemorySegment)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle read$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("read"));
    public static VarHandle read$VH() {
        return fuse3_operations.read$VH;
    }
    public static MemorySegment read$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.read$VH.get(seg);
    }
    public static void read$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.read$VH.set(seg, x);
    }
    public static MemorySegment read$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.read$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void read$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.read$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static read read (MemorySegment segment, SegmentScope scope) {
        return read.ofAddress(read$get(segment), scope);
    }
    static final FunctionDescriptor write$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle write$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.write$FUNC
    );
    public interface write {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2, long _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(write fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(write.class, fi, fuse3_operations.write$FUNC, scope);
        }
        static write ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2, long __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)fuse3_operations.write$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, __x2, __x3, (java.lang.foreign.MemorySegment)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle write$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("write"));
    public static VarHandle write$VH() {
        return fuse3_operations.write$VH;
    }
    public static MemorySegment write$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.write$VH.get(seg);
    }
    public static void write$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.write$VH.set(seg, x);
    }
    public static MemorySegment write$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.write$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void write$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.write$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static write write (MemorySegment segment, SegmentScope scope) {
        return write.ofAddress(write$get(segment), scope);
    }
    static final FunctionDescriptor statfs$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle statfs$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.statfs$FUNC
    );
    public interface statfs {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(statfs fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(statfs.class, fi, fuse3_operations.statfs$FUNC, scope);
        }
        static statfs ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse3_operations.statfs$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle statfs$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("statfs"));
    public static VarHandle statfs$VH() {
        return fuse3_operations.statfs$VH;
    }
    public static MemorySegment statfs$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.statfs$VH.get(seg);
    }
    public static void statfs$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.statfs$VH.set(seg, x);
    }
    public static MemorySegment statfs$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.statfs$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void statfs$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.statfs$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static statfs statfs (MemorySegment segment, SegmentScope scope) {
        return statfs.ofAddress(statfs$get(segment), scope);
    }
    static final FunctionDescriptor flush$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle flush$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.flush$FUNC
    );
    public interface flush {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(flush fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(flush.class, fi, fuse3_operations.flush$FUNC, scope);
        }
        static flush ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse3_operations.flush$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle flush$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("flush"));
    public static VarHandle flush$VH() {
        return fuse3_operations.flush$VH;
    }
    public static MemorySegment flush$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.flush$VH.get(seg);
    }
    public static void flush$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.flush$VH.set(seg, x);
    }
    public static MemorySegment flush$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.flush$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void flush$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.flush$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static flush flush (MemorySegment segment, SegmentScope scope) {
        return flush.ofAddress(flush$get(segment), scope);
    }
    static final FunctionDescriptor release$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle release$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.release$FUNC
    );
    public interface release {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(release fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(release.class, fi, fuse3_operations.release$FUNC, scope);
        }
        static release ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse3_operations.release$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle release$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("release"));
    public static VarHandle release$VH() {
        return fuse3_operations.release$VH;
    }
    public static MemorySegment release$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.release$VH.get(seg);
    }
    public static void release$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.release$VH.set(seg, x);
    }
    public static MemorySegment release$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.release$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void release$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.release$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static release release (MemorySegment segment, SegmentScope scope) {
        return release.ofAddress(release$get(segment), scope);
    }
    static final FunctionDescriptor fsync$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle fsync$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.fsync$FUNC
    );
    public interface fsync {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(fsync fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(fsync.class, fi, fuse3_operations.fsync$FUNC, scope);
        }
        static fsync ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse3_operations.fsync$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, __x1, (java.lang.foreign.MemorySegment)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle fsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fsync"));
    public static VarHandle fsync$VH() {
        return fuse3_operations.fsync$VH;
    }
    public static MemorySegment fsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.fsync$VH.get(seg);
    }
    public static void fsync$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.fsync$VH.set(seg, x);
    }
    public static MemorySegment fsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.fsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fsync$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.fsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static fsync fsync (MemorySegment segment, SegmentScope scope) {
        return fsync.ofAddress(fsync$get(segment), scope);
    }
    static final FunctionDescriptor setxattr$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle setxattr$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.setxattr$FUNC
    );
    public interface setxattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, long _x3, int _x4);
        static MemorySegment allocate(setxattr fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(setxattr.class, fi, fuse3_operations.setxattr$FUNC, scope);
        }
        static setxattr ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, long __x3, int __x4) -> {
                try {
                    return (int)fuse3_operations.setxattr$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, (java.lang.foreign.MemorySegment)__x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle setxattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("setxattr"));
    public static VarHandle setxattr$VH() {
        return fuse3_operations.setxattr$VH;
    }
    public static MemorySegment setxattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.setxattr$VH.get(seg);
    }
    public static void setxattr$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.setxattr$VH.set(seg, x);
    }
    public static MemorySegment setxattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.setxattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void setxattr$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.setxattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static setxattr setxattr (MemorySegment segment, SegmentScope scope) {
        return setxattr.ofAddress(setxattr$get(segment), scope);
    }
    static final FunctionDescriptor getxattr$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle getxattr$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.getxattr$FUNC
    );
    public interface getxattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, long _x3);
        static MemorySegment allocate(getxattr fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(getxattr.class, fi, fuse3_operations.getxattr$FUNC, scope);
        }
        static getxattr ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, long __x3) -> {
                try {
                    return (int)fuse3_operations.getxattr$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, (java.lang.foreign.MemorySegment)__x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle getxattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("getxattr"));
    public static VarHandle getxattr$VH() {
        return fuse3_operations.getxattr$VH;
    }
    public static MemorySegment getxattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.getxattr$VH.get(seg);
    }
    public static void getxattr$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.getxattr$VH.set(seg, x);
    }
    public static MemorySegment getxattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.getxattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void getxattr$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.getxattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static getxattr getxattr (MemorySegment segment, SegmentScope scope) {
        return getxattr.ofAddress(getxattr$get(segment), scope);
    }
    static final FunctionDescriptor listxattr$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle listxattr$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.listxattr$FUNC
    );
    public interface listxattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2);
        static MemorySegment allocate(listxattr fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(listxattr.class, fi, fuse3_operations.listxattr$FUNC, scope);
        }
        static listxattr ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2) -> {
                try {
                    return (int)fuse3_operations.listxattr$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle listxattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("listxattr"));
    public static VarHandle listxattr$VH() {
        return fuse3_operations.listxattr$VH;
    }
    public static MemorySegment listxattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.listxattr$VH.get(seg);
    }
    public static void listxattr$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.listxattr$VH.set(seg, x);
    }
    public static MemorySegment listxattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.listxattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void listxattr$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.listxattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static listxattr listxattr (MemorySegment segment, SegmentScope scope) {
        return listxattr.ofAddress(listxattr$get(segment), scope);
    }
    static final FunctionDescriptor removexattr$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle removexattr$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.removexattr$FUNC
    );
    public interface removexattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(removexattr fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(removexattr.class, fi, fuse3_operations.removexattr$FUNC, scope);
        }
        static removexattr ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse3_operations.removexattr$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle removexattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("removexattr"));
    public static VarHandle removexattr$VH() {
        return fuse3_operations.removexattr$VH;
    }
    public static MemorySegment removexattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.removexattr$VH.get(seg);
    }
    public static void removexattr$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.removexattr$VH.set(seg, x);
    }
    public static MemorySegment removexattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.removexattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void removexattr$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.removexattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static removexattr removexattr (MemorySegment segment, SegmentScope scope) {
        return removexattr.ofAddress(removexattr$get(segment), scope);
    }
    static final FunctionDescriptor opendir$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle opendir$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.opendir$FUNC
    );
    public interface opendir {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(opendir fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(opendir.class, fi, fuse3_operations.opendir$FUNC, scope);
        }
        static opendir ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse3_operations.opendir$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle opendir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("opendir"));
    public static VarHandle opendir$VH() {
        return fuse3_operations.opendir$VH;
    }
    public static MemorySegment opendir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.opendir$VH.get(seg);
    }
    public static void opendir$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.opendir$VH.set(seg, x);
    }
    public static MemorySegment opendir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.opendir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void opendir$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.opendir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static opendir opendir (MemorySegment segment, SegmentScope scope) {
        return opendir.ofAddress(opendir$get(segment), scope);
    }
    static final FunctionDescriptor readdir$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle readdir$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.readdir$FUNC
    );
    public interface readdir {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, long _x3, java.lang.foreign.MemorySegment _x4, int _x5);
        static MemorySegment allocate(readdir fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(readdir.class, fi, fuse3_operations.readdir$FUNC, scope);
        }
        static readdir ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, long __x3, java.lang.foreign.MemorySegment __x4, int __x5) -> {
                try {
                    return (int)fuse3_operations.readdir$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, (java.lang.foreign.MemorySegment)__x2, __x3, (java.lang.foreign.MemorySegment)__x4, __x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle readdir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("readdir"));
    public static VarHandle readdir$VH() {
        return fuse3_operations.readdir$VH;
    }
    public static MemorySegment readdir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.readdir$VH.get(seg);
    }
    public static void readdir$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.readdir$VH.set(seg, x);
    }
    public static MemorySegment readdir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.readdir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void readdir$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.readdir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static readdir readdir (MemorySegment segment, SegmentScope scope) {
        return readdir.ofAddress(readdir$get(segment), scope);
    }
    static final FunctionDescriptor releasedir$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle releasedir$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.releasedir$FUNC
    );
    public interface releasedir {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(releasedir fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(releasedir.class, fi, fuse3_operations.releasedir$FUNC, scope);
        }
        static releasedir ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse3_operations.releasedir$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle releasedir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("releasedir"));
    public static VarHandle releasedir$VH() {
        return fuse3_operations.releasedir$VH;
    }
    public static MemorySegment releasedir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.releasedir$VH.get(seg);
    }
    public static void releasedir$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.releasedir$VH.set(seg, x);
    }
    public static MemorySegment releasedir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.releasedir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void releasedir$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.releasedir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static releasedir releasedir (MemorySegment segment, SegmentScope scope) {
        return releasedir.ofAddress(releasedir$get(segment), scope);
    }
    static final FunctionDescriptor fsyncdir$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle fsyncdir$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.fsyncdir$FUNC
    );
    public interface fsyncdir {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(fsyncdir fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(fsyncdir.class, fi, fuse3_operations.fsyncdir$FUNC, scope);
        }
        static fsyncdir ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse3_operations.fsyncdir$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, __x1, (java.lang.foreign.MemorySegment)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle fsyncdir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fsyncdir"));
    public static VarHandle fsyncdir$VH() {
        return fuse3_operations.fsyncdir$VH;
    }
    public static MemorySegment fsyncdir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.fsyncdir$VH.get(seg);
    }
    public static void fsyncdir$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.fsyncdir$VH.set(seg, x);
    }
    public static MemorySegment fsyncdir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.fsyncdir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fsyncdir$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.fsyncdir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static fsyncdir fsyncdir (MemorySegment segment, SegmentScope scope) {
        return fsyncdir.ofAddress(fsyncdir$get(segment), scope);
    }
    static final FunctionDescriptor init$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle init$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.init$FUNC
    );
    public interface init {

        java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(init fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(init.class, fi, fuse3_operations.init$FUNC, scope);
        }
        static init ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (java.lang.foreign.MemorySegment)(java.lang.foreign.MemorySegment)fuse3_operations.init$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle init$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("init"));
    public static VarHandle init$VH() {
        return fuse3_operations.init$VH;
    }
    public static MemorySegment init$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.init$VH.get(seg);
    }
    public static void init$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.init$VH.set(seg, x);
    }
    public static MemorySegment init$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.init$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void init$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.init$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static init init (MemorySegment segment, SegmentScope scope) {
        return init.ofAddress(init$get(segment), scope);
    }
    static final FunctionDescriptor destroy$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle destroy$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.destroy$FUNC
    );
    public interface destroy {

        void apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(destroy fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(destroy.class, fi, fuse3_operations.destroy$FUNC, scope);
        }
        static destroy ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    fuse3_operations.destroy$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle destroy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("destroy"));
    public static VarHandle destroy$VH() {
        return fuse3_operations.destroy$VH;
    }
    public static MemorySegment destroy$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.destroy$VH.get(seg);
    }
    public static void destroy$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.destroy$VH.set(seg, x);
    }
    public static MemorySegment destroy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.destroy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void destroy$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.destroy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static destroy destroy (MemorySegment segment, SegmentScope scope) {
        return destroy.ofAddress(destroy$get(segment), scope);
    }
    static final FunctionDescriptor access$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle access$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.access$FUNC
    );
    public interface access {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1);
        static MemorySegment allocate(access fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(access.class, fi, fuse3_operations.access$FUNC, scope);
        }
        static access ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1) -> {
                try {
                    return (int)fuse3_operations.access$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle access$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("access"));
    public static VarHandle access$VH() {
        return fuse3_operations.access$VH;
    }
    public static MemorySegment access$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.access$VH.get(seg);
    }
    public static void access$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.access$VH.set(seg, x);
    }
    public static MemorySegment access$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.access$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void access$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.access$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static access access (MemorySegment segment, SegmentScope scope) {
        return access.ofAddress(access$get(segment), scope);
    }
    static final FunctionDescriptor create$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle create$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.create$FUNC
    );
    public interface create {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(create fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(create.class, fi, fuse3_operations.create$FUNC, scope);
        }
        static create ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse3_operations.create$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, __x1, (java.lang.foreign.MemorySegment)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle create$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("create"));
    public static VarHandle create$VH() {
        return fuse3_operations.create$VH;
    }
    public static MemorySegment create$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.create$VH.get(seg);
    }
    public static void create$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.create$VH.set(seg, x);
    }
    public static MemorySegment create$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.create$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void create$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.create$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static create create (MemorySegment segment, SegmentScope scope) {
        return create.ofAddress(create$get(segment), scope);
    }
    static final FunctionDescriptor lock$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle lock$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.lock$FUNC
    );
    public interface lock {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, int _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(lock fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(lock.class, fi, fuse3_operations.lock$FUNC, scope);
        }
        static lock ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, int __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    return (int)fuse3_operations.lock$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, __x2, (java.lang.foreign.MemorySegment)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle lock$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("lock"));
    public static VarHandle lock$VH() {
        return fuse3_operations.lock$VH;
    }
    public static MemorySegment lock$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.lock$VH.get(seg);
    }
    public static void lock$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.lock$VH.set(seg, x);
    }
    public static MemorySegment lock$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.lock$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void lock$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.lock$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static lock lock (MemorySegment segment, SegmentScope scope) {
        return lock.ofAddress(lock$get(segment), scope);
    }
    static final FunctionDescriptor utimens$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle utimens$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.utimens$FUNC
    );
    public interface utimens {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(utimens fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(utimens.class, fi, fuse3_operations.utimens$FUNC, scope);
        }
        static utimens ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse3_operations.utimens$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, (java.lang.foreign.MemorySegment)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle utimens$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("utimens"));
    public static VarHandle utimens$VH() {
        return fuse3_operations.utimens$VH;
    }
    public static MemorySegment utimens$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.utimens$VH.get(seg);
    }
    public static void utimens$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.utimens$VH.set(seg, x);
    }
    public static MemorySegment utimens$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.utimens$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void utimens$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.utimens$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static utimens utimens (MemorySegment segment, SegmentScope scope) {
        return utimens.ofAddress(utimens$get(segment), scope);
    }
    static final FunctionDescriptor bmap$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle bmap$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.bmap$FUNC
    );
    public interface bmap {

        int apply(java.lang.foreign.MemorySegment _x0, long _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(bmap fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(bmap.class, fi, fuse3_operations.bmap$FUNC, scope);
        }
        static bmap ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, long __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse3_operations.bmap$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, __x1, (java.lang.foreign.MemorySegment)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle bmap$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("bmap"));
    public static VarHandle bmap$VH() {
        return fuse3_operations.bmap$VH;
    }
    public static MemorySegment bmap$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.bmap$VH.get(seg);
    }
    public static void bmap$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.bmap$VH.set(seg, x);
    }
    public static MemorySegment bmap$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.bmap$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void bmap$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.bmap$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static bmap bmap (MemorySegment segment, SegmentScope scope) {
        return bmap.ofAddress(bmap$get(segment), scope);
    }
    static final FunctionDescriptor ioctl$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ioctl$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.ioctl$FUNC
    );
    public interface ioctl {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3, int _x4, java.lang.foreign.MemorySegment _x5);
        static MemorySegment allocate(ioctl fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(ioctl.class, fi, fuse3_operations.ioctl$FUNC, scope);
        }
        static ioctl ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3, int __x4, java.lang.foreign.MemorySegment __x5) -> {
                try {
                    return (int)fuse3_operations.ioctl$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, __x1, (java.lang.foreign.MemorySegment)__x2, (java.lang.foreign.MemorySegment)__x3, __x4, (java.lang.foreign.MemorySegment)__x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ioctl$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ioctl"));
    public static VarHandle ioctl$VH() {
        return fuse3_operations.ioctl$VH;
    }
    public static MemorySegment ioctl$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.ioctl$VH.get(seg);
    }
    public static void ioctl$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.ioctl$VH.set(seg, x);
    }
    public static MemorySegment ioctl$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.ioctl$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ioctl$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.ioctl$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ioctl ioctl (MemorySegment segment, SegmentScope scope) {
        return ioctl.ofAddress(ioctl$get(segment), scope);
    }
    static final FunctionDescriptor poll$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle poll$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.poll$FUNC
    );
    public interface poll {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(poll fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(poll.class, fi, fuse3_operations.poll$FUNC, scope);
        }
        static poll ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    return (int)fuse3_operations.poll$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, (java.lang.foreign.MemorySegment)__x2, (java.lang.foreign.MemorySegment)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle poll$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("poll"));
    public static VarHandle poll$VH() {
        return fuse3_operations.poll$VH;
    }
    public static MemorySegment poll$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.poll$VH.get(seg);
    }
    public static void poll$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.poll$VH.set(seg, x);
    }
    public static MemorySegment poll$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.poll$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void poll$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.poll$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static poll poll (MemorySegment segment, SegmentScope scope) {
        return poll.ofAddress(poll$get(segment), scope);
    }
    static final FunctionDescriptor write_buf$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle write_buf$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.write_buf$FUNC
    );
    public interface write_buf {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(write_buf fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(write_buf.class, fi, fuse3_operations.write_buf$FUNC, scope);
        }
        static write_buf ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    return (int)fuse3_operations.write_buf$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, __x2, (java.lang.foreign.MemorySegment)__x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle write_buf$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("write_buf"));
    public static VarHandle write_buf$VH() {
        return fuse3_operations.write_buf$VH;
    }
    public static MemorySegment write_buf$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.write_buf$VH.get(seg);
    }
    public static void write_buf$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.write_buf$VH.set(seg, x);
    }
    public static MemorySegment write_buf$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.write_buf$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void write_buf$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.write_buf$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static write_buf write_buf (MemorySegment segment, SegmentScope scope) {
        return write_buf.ofAddress(write_buf$get(segment), scope);
    }
    static final FunctionDescriptor read_buf$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle read_buf$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.read_buf$FUNC
    );
    public interface read_buf {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2, long _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(read_buf fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(read_buf.class, fi, fuse3_operations.read_buf$FUNC, scope);
        }
        static read_buf ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2, long __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)fuse3_operations.read_buf$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, __x2, __x3, (java.lang.foreign.MemorySegment)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle read_buf$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("read_buf"));
    public static VarHandle read_buf$VH() {
        return fuse3_operations.read_buf$VH;
    }
    public static MemorySegment read_buf$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.read_buf$VH.get(seg);
    }
    public static void read_buf$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.read_buf$VH.set(seg, x);
    }
    public static MemorySegment read_buf$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.read_buf$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void read_buf$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.read_buf$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static read_buf read_buf (MemorySegment segment, SegmentScope scope) {
        return read_buf.ofAddress(read_buf$get(segment), scope);
    }
    static final FunctionDescriptor flock$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle flock$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.flock$FUNC
    );
    public interface flock {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, int _x2);
        static MemorySegment allocate(flock fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(flock.class, fi, fuse3_operations.flock$FUNC, scope);
        }
        static flock ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, int __x2) -> {
                try {
                    return (int)fuse3_operations.flock$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, (java.lang.foreign.MemorySegment)__x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle flock$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("flock"));
    public static VarHandle flock$VH() {
        return fuse3_operations.flock$VH;
    }
    public static MemorySegment flock$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.flock$VH.get(seg);
    }
    public static void flock$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.flock$VH.set(seg, x);
    }
    public static MemorySegment flock$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.flock$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void flock$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.flock$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static flock flock (MemorySegment segment, SegmentScope scope) {
        return flock.ofAddress(flock$get(segment), scope);
    }
    static final FunctionDescriptor fallocate$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle fallocate$MH = RuntimeHelper.downcallHandle(
        fuse3_operations.fallocate$FUNC
    );
    public interface fallocate {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, long _x2, long _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(fallocate fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(fallocate.class, fi, fuse3_operations.fallocate$FUNC, scope);
        }
        static fallocate ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, long __x2, long __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)fuse3_operations.fallocate$MH.invokeExact((MemorySegment)symbol, (java.lang.foreign.MemorySegment)__x0, __x1, __x2, __x3, (java.lang.foreign.MemorySegment)__x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle fallocate$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fallocate"));
    public static VarHandle fallocate$VH() {
        return fuse3_operations.fallocate$VH;
    }
    public static MemorySegment fallocate$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.fallocate$VH.get(seg);
    }
    public static void fallocate$set( MemorySegment seg, MemorySegment x) {
        fuse3_operations.fallocate$VH.set(seg, x);
    }
    public static MemorySegment fallocate$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse3_operations.fallocate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fallocate$set(MemorySegment seg, long index, MemorySegment x) {
        fuse3_operations.fallocate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static fallocate fallocate (MemorySegment segment, SegmentScope scope) {
        return fallocate.ofAddress(fallocate$get(segment), scope);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemorySegment addr, SegmentScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


