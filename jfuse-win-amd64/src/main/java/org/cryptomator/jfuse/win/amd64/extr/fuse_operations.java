// Generated by jextract

package org.cryptomator.jfuse.win.amd64.extr;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;

import jdk.incubator.foreign.*;

public class fuse_operations {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("getattr"),
        Constants$root.C_POINTER$LAYOUT.withName("getdir"),
        Constants$root.C_POINTER$LAYOUT.withName("readlink"),
        Constants$root.C_POINTER$LAYOUT.withName("mknod"),
        Constants$root.C_POINTER$LAYOUT.withName("mkdir"),
        Constants$root.C_POINTER$LAYOUT.withName("unlink"),
        Constants$root.C_POINTER$LAYOUT.withName("rmdir"),
        Constants$root.C_POINTER$LAYOUT.withName("symlink"),
        Constants$root.C_POINTER$LAYOUT.withName("rename"),
        Constants$root.C_POINTER$LAYOUT.withName("link"),
        Constants$root.C_POINTER$LAYOUT.withName("chmod"),
        Constants$root.C_POINTER$LAYOUT.withName("chown"),
        Constants$root.C_POINTER$LAYOUT.withName("truncate"),
        Constants$root.C_POINTER$LAYOUT.withName("utime"),
        Constants$root.C_POINTER$LAYOUT.withName("open"),
        Constants$root.C_POINTER$LAYOUT.withName("read"),
        Constants$root.C_POINTER$LAYOUT.withName("write"),
        Constants$root.C_POINTER$LAYOUT.withName("statfs"),
        Constants$root.C_POINTER$LAYOUT.withName("flush"),
        Constants$root.C_POINTER$LAYOUT.withName("release"),
        Constants$root.C_POINTER$LAYOUT.withName("fsync"),
        Constants$root.C_POINTER$LAYOUT.withName("setxattr"),
        Constants$root.C_POINTER$LAYOUT.withName("getxattr"),
        Constants$root.C_POINTER$LAYOUT.withName("listxattr"),
        Constants$root.C_POINTER$LAYOUT.withName("removexattr"),
        Constants$root.C_POINTER$LAYOUT.withName("opendir"),
        Constants$root.C_POINTER$LAYOUT.withName("readdir"),
        Constants$root.C_POINTER$LAYOUT.withName("releasedir"),
        Constants$root.C_POINTER$LAYOUT.withName("fsyncdir"),
        Constants$root.C_POINTER$LAYOUT.withName("init"),
        Constants$root.C_POINTER$LAYOUT.withName("destroy"),
        Constants$root.C_POINTER$LAYOUT.withName("access"),
        Constants$root.C_POINTER$LAYOUT.withName("create"),
        Constants$root.C_POINTER$LAYOUT.withName("ftruncate"),
        Constants$root.C_POINTER$LAYOUT.withName("fgetattr"),
        Constants$root.C_POINTER$LAYOUT.withName("lock"),
        Constants$root.C_POINTER$LAYOUT.withName("utimens"),
        Constants$root.C_POINTER$LAYOUT.withName("bmap"),
        MemoryLayout.structLayout(
            MemoryLayout.paddingLayout(1).withName("flag_nullpath_ok"),
            MemoryLayout.paddingLayout(1).withName("flag_nopath"),
            MemoryLayout.paddingLayout(1).withName("flag_utime_omit_ok"),
            MemoryLayout.paddingLayout(29).withName("flag_reserved"),
            MemoryLayout.paddingLayout(32)
        ),
        Constants$root.C_POINTER$LAYOUT.withName("ioctl"),
        Constants$root.C_POINTER$LAYOUT.withName("poll"),
        Constants$root.C_POINTER$LAYOUT.withName("write_buf"),
        Constants$root.C_POINTER$LAYOUT.withName("read_buf"),
        Constants$root.C_POINTER$LAYOUT.withName("flock"),
        Constants$root.C_POINTER$LAYOUT.withName("fallocate"),
        Constants$root.C_POINTER$LAYOUT.withName("reserved00"),
        Constants$root.C_POINTER$LAYOUT.withName("reserved01"),
        Constants$root.C_POINTER$LAYOUT.withName("reserved02"),
        Constants$root.C_POINTER$LAYOUT.withName("statfs_x"),
        Constants$root.C_POINTER$LAYOUT.withName("setvolname"),
        Constants$root.C_POINTER$LAYOUT.withName("exchange"),
        Constants$root.C_POINTER$LAYOUT.withName("getxtimes"),
        Constants$root.C_POINTER$LAYOUT.withName("setbkuptime"),
        Constants$root.C_POINTER$LAYOUT.withName("setchgtime"),
        Constants$root.C_POINTER$LAYOUT.withName("setcrtime"),
        Constants$root.C_POINTER$LAYOUT.withName("chflags"),
        Constants$root.C_POINTER$LAYOUT.withName("setattr_x"),
        Constants$root.C_POINTER$LAYOUT.withName("fsetattr_x")
    ).withName("fuse_operations");
    public static MemoryLayout $LAYOUT() {
        return fuse_operations.$struct$LAYOUT;
    }
    static final FunctionDescriptor getattr$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle getattr$MH = RuntimeHelper.downcallHandle(
        fuse_operations.getattr$FUNC, false
    );
    public interface getattr {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(getattr fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(getattr.class, fi, fuse_operations.getattr$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static getattr ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("getattr::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.getattr$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle getattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("getattr"));
    public static VarHandle getattr$VH() {
        return fuse_operations.getattr$VH;
    }
    public static MemoryAddress getattr$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.getattr$VH.get(seg);
    }
    public static void getattr$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.getattr$VH.set(seg, x);
    }
    public static MemoryAddress getattr$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.getattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void getattr$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.getattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static getattr getattr (MemorySegment segment, ResourceScope scope) {
        return getattr.ofAddress(getattr$get(segment), scope);
    }
    static final FunctionDescriptor getdir$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle getdir$MH = RuntimeHelper.downcallHandle(
        fuse_operations.getdir$FUNC, false
    );
    public interface getdir {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);
        static NativeSymbol allocate(getdir fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(getdir.class, fi, fuse_operations.getdir$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static getdir ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("getdir::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)fuse_operations.getdir$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, (jdk.incubator.foreign.Addressable)x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle getdir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("getdir"));
    public static VarHandle getdir$VH() {
        return fuse_operations.getdir$VH;
    }
    public static MemoryAddress getdir$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.getdir$VH.get(seg);
    }
    public static void getdir$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.getdir$VH.set(seg, x);
    }
    public static MemoryAddress getdir$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.getdir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void getdir$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.getdir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static getdir getdir (MemorySegment segment, ResourceScope scope) {
        return getdir.ofAddress(getdir$get(segment), scope);
    }
    static final FunctionDescriptor readlink$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle readlink$MH = RuntimeHelper.downcallHandle(
        fuse_operations.readlink$FUNC, false
    );
    public interface readlink {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, long x2);
        static NativeSymbol allocate(readlink fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(readlink.class, fi, fuse_operations.readlink$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;J)I", scope);
        }
        static readlink ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("readlink::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, long x2) -> {
                try {
                    return (int)fuse_operations.readlink$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle readlink$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("readlink"));
    public static VarHandle readlink$VH() {
        return fuse_operations.readlink$VH;
    }
    public static MemoryAddress readlink$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.readlink$VH.get(seg);
    }
    public static void readlink$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.readlink$VH.set(seg, x);
    }
    public static MemoryAddress readlink$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.readlink$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void readlink$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.readlink$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static readlink readlink (MemorySegment segment, ResourceScope scope) {
        return readlink.ofAddress(readlink$get(segment), scope);
    }
    static final FunctionDescriptor mknod$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle mknod$MH = RuntimeHelper.downcallHandle(
        fuse_operations.mknod$FUNC, false
    );
    public interface mknod {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, int x2);
        static NativeSymbol allocate(mknod fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(mknod.class, fi, fuse_operations.mknod$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;II)I", scope);
        }
        static mknod ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("mknod::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, int x1, int x2) -> {
                try {
                    return (int)fuse_operations.mknod$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mknod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("mknod"));
    public static VarHandle mknod$VH() {
        return fuse_operations.mknod$VH;
    }
    public static MemoryAddress mknod$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.mknod$VH.get(seg);
    }
    public static void mknod$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.mknod$VH.set(seg, x);
    }
    public static MemoryAddress mknod$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.mknod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mknod$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.mknod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mknod mknod (MemorySegment segment, ResourceScope scope) {
        return mknod.ofAddress(mknod$get(segment), scope);
    }
    static final FunctionDescriptor mkdir$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle mkdir$MH = RuntimeHelper.downcallHandle(
        fuse_operations.mkdir$FUNC, false
    );
    public interface mkdir {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1);
        static NativeSymbol allocate(mkdir fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(mkdir.class, fi, fuse_operations.mkdir$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)I", scope);
        }
        static mkdir ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("mkdir::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, int x1) -> {
                try {
                    return (int)fuse_operations.mkdir$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mkdir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("mkdir"));
    public static VarHandle mkdir$VH() {
        return fuse_operations.mkdir$VH;
    }
    public static MemoryAddress mkdir$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.mkdir$VH.get(seg);
    }
    public static void mkdir$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.mkdir$VH.set(seg, x);
    }
    public static MemoryAddress mkdir$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.mkdir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mkdir$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.mkdir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mkdir mkdir (MemorySegment segment, ResourceScope scope) {
        return mkdir.ofAddress(mkdir$get(segment), scope);
    }
    static final FunctionDescriptor unlink$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle unlink$MH = RuntimeHelper.downcallHandle(
        fuse_operations.unlink$FUNC, false
    );
    public interface unlink {

        int apply(jdk.incubator.foreign.MemoryAddress x0);
        static NativeSymbol allocate(unlink fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(unlink.class, fi, fuse_operations.unlink$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static unlink ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("unlink::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (int)fuse_operations.unlink$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle unlink$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("unlink"));
    public static VarHandle unlink$VH() {
        return fuse_operations.unlink$VH;
    }
    public static MemoryAddress unlink$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.unlink$VH.get(seg);
    }
    public static void unlink$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.unlink$VH.set(seg, x);
    }
    public static MemoryAddress unlink$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.unlink$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void unlink$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.unlink$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static unlink unlink (MemorySegment segment, ResourceScope scope) {
        return unlink.ofAddress(unlink$get(segment), scope);
    }
    static final FunctionDescriptor rmdir$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle rmdir$MH = RuntimeHelper.downcallHandle(
        fuse_operations.rmdir$FUNC, false
    );
    public interface rmdir {

        int apply(jdk.incubator.foreign.MemoryAddress x0);
        static NativeSymbol allocate(rmdir fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(rmdir.class, fi, fuse_operations.rmdir$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static rmdir ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("rmdir::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (int)fuse_operations.rmdir$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle rmdir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("rmdir"));
    public static VarHandle rmdir$VH() {
        return fuse_operations.rmdir$VH;
    }
    public static MemoryAddress rmdir$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.rmdir$VH.get(seg);
    }
    public static void rmdir$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.rmdir$VH.set(seg, x);
    }
    public static MemoryAddress rmdir$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.rmdir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void rmdir$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.rmdir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static rmdir rmdir (MemorySegment segment, ResourceScope scope) {
        return rmdir.ofAddress(rmdir$get(segment), scope);
    }
    static final FunctionDescriptor symlink$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle symlink$MH = RuntimeHelper.downcallHandle(
        fuse_operations.symlink$FUNC, false
    );
    public interface symlink {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(symlink fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(symlink.class, fi, fuse_operations.symlink$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static symlink ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("symlink::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.symlink$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle symlink$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("symlink"));
    public static VarHandle symlink$VH() {
        return fuse_operations.symlink$VH;
    }
    public static MemoryAddress symlink$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.symlink$VH.get(seg);
    }
    public static void symlink$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.symlink$VH.set(seg, x);
    }
    public static MemoryAddress symlink$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.symlink$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void symlink$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.symlink$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static symlink symlink (MemorySegment segment, ResourceScope scope) {
        return symlink.ofAddress(symlink$get(segment), scope);
    }
    static final FunctionDescriptor rename$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle rename$MH = RuntimeHelper.downcallHandle(
        fuse_operations.rename$FUNC, false
    );
    public interface rename {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(rename fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(rename.class, fi, fuse_operations.rename$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static rename ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("rename::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.rename$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle rename$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("rename"));
    public static VarHandle rename$VH() {
        return fuse_operations.rename$VH;
    }
    public static MemoryAddress rename$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.rename$VH.get(seg);
    }
    public static void rename$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.rename$VH.set(seg, x);
    }
    public static MemoryAddress rename$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.rename$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void rename$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.rename$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static rename rename (MemorySegment segment, ResourceScope scope) {
        return rename.ofAddress(rename$get(segment), scope);
    }
    static final FunctionDescriptor link$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle link$MH = RuntimeHelper.downcallHandle(
        fuse_operations.link$FUNC, false
    );
    public interface link {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(link fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(link.class, fi, fuse_operations.link$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static link ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("link::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.link$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle link$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("link"));
    public static VarHandle link$VH() {
        return fuse_operations.link$VH;
    }
    public static MemoryAddress link$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.link$VH.get(seg);
    }
    public static void link$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.link$VH.set(seg, x);
    }
    public static MemoryAddress link$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.link$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void link$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.link$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static link link (MemorySegment segment, ResourceScope scope) {
        return link.ofAddress(link$get(segment), scope);
    }
    static final FunctionDescriptor chmod$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle chmod$MH = RuntimeHelper.downcallHandle(
        fuse_operations.chmod$FUNC, false
    );
    public interface chmod {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1);
        static NativeSymbol allocate(chmod fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(chmod.class, fi, fuse_operations.chmod$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)I", scope);
        }
        static chmod ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("chmod::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, int x1) -> {
                try {
                    return (int)fuse_operations.chmod$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle chmod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("chmod"));
    public static VarHandle chmod$VH() {
        return fuse_operations.chmod$VH;
    }
    public static MemoryAddress chmod$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.chmod$VH.get(seg);
    }
    public static void chmod$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.chmod$VH.set(seg, x);
    }
    public static MemoryAddress chmod$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.chmod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void chmod$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.chmod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static chmod chmod (MemorySegment segment, ResourceScope scope) {
        return chmod.ofAddress(chmod$get(segment), scope);
    }
    static final FunctionDescriptor chown$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle chown$MH = RuntimeHelper.downcallHandle(
        fuse_operations.chown$FUNC, false
    );
    public interface chown {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, int x2);
        static NativeSymbol allocate(chown fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(chown.class, fi, fuse_operations.chown$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;II)I", scope);
        }
        static chown ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("chown::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, int x1, int x2) -> {
                try {
                    return (int)fuse_operations.chown$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle chown$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("chown"));
    public static VarHandle chown$VH() {
        return fuse_operations.chown$VH;
    }
    public static MemoryAddress chown$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.chown$VH.get(seg);
    }
    public static void chown$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.chown$VH.set(seg, x);
    }
    public static MemoryAddress chown$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.chown$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void chown$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.chown$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static chown chown (MemorySegment segment, ResourceScope scope) {
        return chown.ofAddress(chown$get(segment), scope);
    }
    static final FunctionDescriptor truncate$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle truncate$MH = RuntimeHelper.downcallHandle(
        fuse_operations.truncate$FUNC, false
    );
    public interface truncate {

        int apply(jdk.incubator.foreign.MemoryAddress x0, long x1);
        static NativeSymbol allocate(truncate fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(truncate.class, fi, fuse_operations.truncate$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;J)I", scope);
        }
        static truncate ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("truncate::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, long x1) -> {
                try {
                    return (int)fuse_operations.truncate$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle truncate$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("truncate"));
    public static VarHandle truncate$VH() {
        return fuse_operations.truncate$VH;
    }
    public static MemoryAddress truncate$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.truncate$VH.get(seg);
    }
    public static void truncate$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.truncate$VH.set(seg, x);
    }
    public static MemoryAddress truncate$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.truncate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void truncate$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.truncate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static truncate truncate (MemorySegment segment, ResourceScope scope) {
        return truncate.ofAddress(truncate$get(segment), scope);
    }
    static final FunctionDescriptor utime$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle utime$MH = RuntimeHelper.downcallHandle(
        fuse_operations.utime$FUNC, false
    );
    public interface utime {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(utime fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(utime.class, fi, fuse_operations.utime$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static utime ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("utime::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.utime$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle utime$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("utime"));
    public static VarHandle utime$VH() {
        return fuse_operations.utime$VH;
    }
    public static MemoryAddress utime$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.utime$VH.get(seg);
    }
    public static void utime$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.utime$VH.set(seg, x);
    }
    public static MemoryAddress utime$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.utime$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void utime$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.utime$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static utime utime (MemorySegment segment, ResourceScope scope) {
        return utime.ofAddress(utime$get(segment), scope);
    }
    static final FunctionDescriptor open$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle open$MH = RuntimeHelper.downcallHandle(
        fuse_operations.open$FUNC, false
    );
    public interface open {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(open fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(open.class, fi, fuse_operations.open$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static open ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("open::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.open$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle open$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("open"));
    public static VarHandle open$VH() {
        return fuse_operations.open$VH;
    }
    public static MemoryAddress open$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.open$VH.get(seg);
    }
    public static void open$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.open$VH.set(seg, x);
    }
    public static MemoryAddress open$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.open$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void open$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.open$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static open open (MemorySegment segment, ResourceScope scope) {
        return open.ofAddress(open$get(segment), scope);
    }
    static final FunctionDescriptor read$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle read$MH = RuntimeHelper.downcallHandle(
        fuse_operations.read$FUNC, false
    );
    public interface read {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, long x2, long x3, jdk.incubator.foreign.MemoryAddress x4);
        static NativeSymbol allocate(read fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(read.class, fi, fuse_operations.read$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;JJLjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static read ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("read::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, long x2, long x3, jdk.incubator.foreign.MemoryAddress x4) -> {
                try {
                    return (int)fuse_operations.read$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, x2, x3, (jdk.incubator.foreign.Addressable)x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle read$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("read"));
    public static VarHandle read$VH() {
        return fuse_operations.read$VH;
    }
    public static MemoryAddress read$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.read$VH.get(seg);
    }
    public static void read$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.read$VH.set(seg, x);
    }
    public static MemoryAddress read$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.read$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void read$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.read$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static read read (MemorySegment segment, ResourceScope scope) {
        return read.ofAddress(read$get(segment), scope);
    }
    static final FunctionDescriptor write$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle write$MH = RuntimeHelper.downcallHandle(
        fuse_operations.write$FUNC, false
    );
    public interface write {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, long x2, long x3, jdk.incubator.foreign.MemoryAddress x4);
        static NativeSymbol allocate(write fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(write.class, fi, fuse_operations.write$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;JJLjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static write ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("write::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, long x2, long x3, jdk.incubator.foreign.MemoryAddress x4) -> {
                try {
                    return (int)fuse_operations.write$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, x2, x3, (jdk.incubator.foreign.Addressable)x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle write$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("write"));
    public static VarHandle write$VH() {
        return fuse_operations.write$VH;
    }
    public static MemoryAddress write$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.write$VH.get(seg);
    }
    public static void write$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.write$VH.set(seg, x);
    }
    public static MemoryAddress write$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.write$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void write$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.write$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static write write (MemorySegment segment, ResourceScope scope) {
        return write.ofAddress(write$get(segment), scope);
    }
    static final FunctionDescriptor statfs$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle statfs$MH = RuntimeHelper.downcallHandle(
        fuse_operations.statfs$FUNC, false
    );
    public interface statfs {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(statfs fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(statfs.class, fi, fuse_operations.statfs$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static statfs ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("statfs::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.statfs$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle statfs$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("statfs"));
    public static VarHandle statfs$VH() {
        return fuse_operations.statfs$VH;
    }
    public static MemoryAddress statfs$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.statfs$VH.get(seg);
    }
    public static void statfs$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.statfs$VH.set(seg, x);
    }
    public static MemoryAddress statfs$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.statfs$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void statfs$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.statfs$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static statfs statfs (MemorySegment segment, ResourceScope scope) {
        return statfs.ofAddress(statfs$get(segment), scope);
    }
    static final FunctionDescriptor flush$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle flush$MH = RuntimeHelper.downcallHandle(
        fuse_operations.flush$FUNC, false
    );
    public interface flush {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(flush fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(flush.class, fi, fuse_operations.flush$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static flush ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("flush::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.flush$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle flush$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("flush"));
    public static VarHandle flush$VH() {
        return fuse_operations.flush$VH;
    }
    public static MemoryAddress flush$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.flush$VH.get(seg);
    }
    public static void flush$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.flush$VH.set(seg, x);
    }
    public static MemoryAddress flush$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.flush$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void flush$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.flush$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static flush flush (MemorySegment segment, ResourceScope scope) {
        return flush.ofAddress(flush$get(segment), scope);
    }
    static final FunctionDescriptor release$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle release$MH = RuntimeHelper.downcallHandle(
        fuse_operations.release$FUNC, false
    );
    public interface release {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(release fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(release.class, fi, fuse_operations.release$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static release ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("release::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.release$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle release$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("release"));
    public static VarHandle release$VH() {
        return fuse_operations.release$VH;
    }
    public static MemoryAddress release$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.release$VH.get(seg);
    }
    public static void release$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.release$VH.set(seg, x);
    }
    public static MemoryAddress release$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.release$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void release$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.release$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static release release (MemorySegment segment, ResourceScope scope) {
        return release.ofAddress(release$get(segment), scope);
    }
    static final FunctionDescriptor fsync$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle fsync$MH = RuntimeHelper.downcallHandle(
        fuse_operations.fsync$FUNC, false
    );
    public interface fsync {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2);
        static NativeSymbol allocate(fsync fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(fsync.class, fi, fuse_operations.fsync$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static fsync ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("fsync::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)fuse_operations.fsync$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1, (jdk.incubator.foreign.Addressable)x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle fsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fsync"));
    public static VarHandle fsync$VH() {
        return fuse_operations.fsync$VH;
    }
    public static MemoryAddress fsync$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.fsync$VH.get(seg);
    }
    public static void fsync$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.fsync$VH.set(seg, x);
    }
    public static MemoryAddress fsync$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.fsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fsync$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.fsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static fsync fsync (MemorySegment segment, ResourceScope scope) {
        return fsync.ofAddress(fsync$get(segment), scope);
    }
    static final FunctionDescriptor setxattr$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle setxattr$MH = RuntimeHelper.downcallHandle(
        fuse_operations.setxattr$FUNC, false
    );
    public interface setxattr {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, long x3, int x4);
        static NativeSymbol allocate(setxattr fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(setxattr.class, fi, fuse_operations.setxattr$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;JI)I", scope);
        }
        static setxattr ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("setxattr::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, long x3, int x4) -> {
                try {
                    return (int)fuse_operations.setxattr$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, (jdk.incubator.foreign.Addressable)x2, x3, x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle setxattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("setxattr"));
    public static VarHandle setxattr$VH() {
        return fuse_operations.setxattr$VH;
    }
    public static MemoryAddress setxattr$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.setxattr$VH.get(seg);
    }
    public static void setxattr$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.setxattr$VH.set(seg, x);
    }
    public static MemoryAddress setxattr$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.setxattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void setxattr$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.setxattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static setxattr setxattr (MemorySegment segment, ResourceScope scope) {
        return setxattr.ofAddress(setxattr$get(segment), scope);
    }
    static final FunctionDescriptor getxattr$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle getxattr$MH = RuntimeHelper.downcallHandle(
        fuse_operations.getxattr$FUNC, false
    );
    public interface getxattr {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, long x3);
        static NativeSymbol allocate(getxattr fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(getxattr.class, fi, fuse_operations.getxattr$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;J)I", scope);
        }
        static getxattr ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("getxattr::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, long x3) -> {
                try {
                    return (int)fuse_operations.getxattr$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, (jdk.incubator.foreign.Addressable)x2, x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle getxattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("getxattr"));
    public static VarHandle getxattr$VH() {
        return fuse_operations.getxattr$VH;
    }
    public static MemoryAddress getxattr$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.getxattr$VH.get(seg);
    }
    public static void getxattr$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.getxattr$VH.set(seg, x);
    }
    public static MemoryAddress getxattr$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.getxattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void getxattr$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.getxattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static getxattr getxattr (MemorySegment segment, ResourceScope scope) {
        return getxattr.ofAddress(getxattr$get(segment), scope);
    }
    static final FunctionDescriptor listxattr$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle listxattr$MH = RuntimeHelper.downcallHandle(
        fuse_operations.listxattr$FUNC, false
    );
    public interface listxattr {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, long x2);
        static NativeSymbol allocate(listxattr fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(listxattr.class, fi, fuse_operations.listxattr$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;J)I", scope);
        }
        static listxattr ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("listxattr::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, long x2) -> {
                try {
                    return (int)fuse_operations.listxattr$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle listxattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("listxattr"));
    public static VarHandle listxattr$VH() {
        return fuse_operations.listxattr$VH;
    }
    public static MemoryAddress listxattr$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.listxattr$VH.get(seg);
    }
    public static void listxattr$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.listxattr$VH.set(seg, x);
    }
    public static MemoryAddress listxattr$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.listxattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void listxattr$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.listxattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static listxattr listxattr (MemorySegment segment, ResourceScope scope) {
        return listxattr.ofAddress(listxattr$get(segment), scope);
    }
    static final FunctionDescriptor removexattr$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle removexattr$MH = RuntimeHelper.downcallHandle(
        fuse_operations.removexattr$FUNC, false
    );
    public interface removexattr {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(removexattr fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(removexattr.class, fi, fuse_operations.removexattr$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static removexattr ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("removexattr::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.removexattr$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle removexattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("removexattr"));
    public static VarHandle removexattr$VH() {
        return fuse_operations.removexattr$VH;
    }
    public static MemoryAddress removexattr$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.removexattr$VH.get(seg);
    }
    public static void removexattr$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.removexattr$VH.set(seg, x);
    }
    public static MemoryAddress removexattr$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.removexattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void removexattr$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.removexattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static removexattr removexattr (MemorySegment segment, ResourceScope scope) {
        return removexattr.ofAddress(removexattr$get(segment), scope);
    }
    static final FunctionDescriptor opendir$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle opendir$MH = RuntimeHelper.downcallHandle(
        fuse_operations.opendir$FUNC, false
    );
    public interface opendir {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(opendir fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(opendir.class, fi, fuse_operations.opendir$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static opendir ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("opendir::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.opendir$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle opendir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("opendir"));
    public static VarHandle opendir$VH() {
        return fuse_operations.opendir$VH;
    }
    public static MemoryAddress opendir$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.opendir$VH.get(seg);
    }
    public static void opendir$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.opendir$VH.set(seg, x);
    }
    public static MemoryAddress opendir$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.opendir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void opendir$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.opendir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static opendir opendir (MemorySegment segment, ResourceScope scope) {
        return opendir.ofAddress(opendir$get(segment), scope);
    }
    static final FunctionDescriptor readdir$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle readdir$MH = RuntimeHelper.downcallHandle(
        fuse_operations.readdir$FUNC, false
    );
    public interface readdir {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, long x3, jdk.incubator.foreign.MemoryAddress x4);
        static NativeSymbol allocate(readdir fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(readdir.class, fi, fuse_operations.readdir$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;JLjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static readdir ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("readdir::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, long x3, jdk.incubator.foreign.MemoryAddress x4) -> {
                try {
                    return (int)fuse_operations.readdir$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, (jdk.incubator.foreign.Addressable)x2, x3, (jdk.incubator.foreign.Addressable)x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle readdir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("readdir"));
    public static VarHandle readdir$VH() {
        return fuse_operations.readdir$VH;
    }
    public static MemoryAddress readdir$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.readdir$VH.get(seg);
    }
    public static void readdir$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.readdir$VH.set(seg, x);
    }
    public static MemoryAddress readdir$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.readdir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void readdir$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.readdir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static readdir readdir (MemorySegment segment, ResourceScope scope) {
        return readdir.ofAddress(readdir$get(segment), scope);
    }
    static final FunctionDescriptor releasedir$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle releasedir$MH = RuntimeHelper.downcallHandle(
        fuse_operations.releasedir$FUNC, false
    );
    public interface releasedir {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(releasedir fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(releasedir.class, fi, fuse_operations.releasedir$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static releasedir ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("releasedir::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.releasedir$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle releasedir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("releasedir"));
    public static VarHandle releasedir$VH() {
        return fuse_operations.releasedir$VH;
    }
    public static MemoryAddress releasedir$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.releasedir$VH.get(seg);
    }
    public static void releasedir$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.releasedir$VH.set(seg, x);
    }
    public static MemoryAddress releasedir$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.releasedir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void releasedir$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.releasedir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static releasedir releasedir (MemorySegment segment, ResourceScope scope) {
        return releasedir.ofAddress(releasedir$get(segment), scope);
    }
    static final FunctionDescriptor fsyncdir$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle fsyncdir$MH = RuntimeHelper.downcallHandle(
        fuse_operations.fsyncdir$FUNC, false
    );
    public interface fsyncdir {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2);
        static NativeSymbol allocate(fsyncdir fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(fsyncdir.class, fi, fuse_operations.fsyncdir$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static fsyncdir ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("fsyncdir::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)fuse_operations.fsyncdir$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1, (jdk.incubator.foreign.Addressable)x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle fsyncdir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fsyncdir"));
    public static VarHandle fsyncdir$VH() {
        return fuse_operations.fsyncdir$VH;
    }
    public static MemoryAddress fsyncdir$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.fsyncdir$VH.get(seg);
    }
    public static void fsyncdir$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.fsyncdir$VH.set(seg, x);
    }
    public static MemoryAddress fsyncdir$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.fsyncdir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fsyncdir$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.fsyncdir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static fsyncdir fsyncdir (MemorySegment segment, ResourceScope scope) {
        return fsyncdir.ofAddress(fsyncdir$get(segment), scope);
    }
    static final FunctionDescriptor init$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle init$MH = RuntimeHelper.downcallHandle(
        fuse_operations.init$FUNC, false
    );
    public interface init {

        jdk.incubator.foreign.Addressable apply(jdk.incubator.foreign.MemoryAddress x0);
        static NativeSymbol allocate(init fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(init.class, fi, fuse_operations.init$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/Addressable;", scope);
        }
        static init ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("init::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (jdk.incubator.foreign.Addressable)(jdk.incubator.foreign.MemoryAddress)fuse_operations.init$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle init$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("init"));
    public static VarHandle init$VH() {
        return fuse_operations.init$VH;
    }
    public static MemoryAddress init$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.init$VH.get(seg);
    }
    public static void init$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.init$VH.set(seg, x);
    }
    public static MemoryAddress init$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.init$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void init$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.init$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static init init (MemorySegment segment, ResourceScope scope) {
        return init.ofAddress(init$get(segment), scope);
    }
    static final FunctionDescriptor destroy$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle destroy$MH = RuntimeHelper.downcallHandle(
        fuse_operations.destroy$FUNC, false
    );
    public interface destroy {

        void apply(jdk.incubator.foreign.MemoryAddress x0);
        static NativeSymbol allocate(destroy fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(destroy.class, fi, fuse_operations.destroy$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static destroy ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("destroy::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    fuse_operations.destroy$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle destroy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("destroy"));
    public static VarHandle destroy$VH() {
        return fuse_operations.destroy$VH;
    }
    public static MemoryAddress destroy$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.destroy$VH.get(seg);
    }
    public static void destroy$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.destroy$VH.set(seg, x);
    }
    public static MemoryAddress destroy$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.destroy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void destroy$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.destroy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static destroy destroy (MemorySegment segment, ResourceScope scope) {
        return destroy.ofAddress(destroy$get(segment), scope);
    }
    static final FunctionDescriptor access$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle access$MH = RuntimeHelper.downcallHandle(
        fuse_operations.access$FUNC, false
    );
    public interface access {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1);
        static NativeSymbol allocate(access fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(access.class, fi, fuse_operations.access$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)I", scope);
        }
        static access ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("access::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, int x1) -> {
                try {
                    return (int)fuse_operations.access$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle access$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("access"));
    public static VarHandle access$VH() {
        return fuse_operations.access$VH;
    }
    public static MemoryAddress access$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.access$VH.get(seg);
    }
    public static void access$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.access$VH.set(seg, x);
    }
    public static MemoryAddress access$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.access$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void access$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.access$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static access access (MemorySegment segment, ResourceScope scope) {
        return access.ofAddress(access$get(segment), scope);
    }
    static final FunctionDescriptor create$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle create$MH = RuntimeHelper.downcallHandle(
        fuse_operations.create$FUNC, false
    );
    public interface create {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2);
        static NativeSymbol allocate(create fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(create.class, fi, fuse_operations.create$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static create ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("create::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)fuse_operations.create$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1, (jdk.incubator.foreign.Addressable)x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle create$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("create"));
    public static VarHandle create$VH() {
        return fuse_operations.create$VH;
    }
    public static MemoryAddress create$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.create$VH.get(seg);
    }
    public static void create$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.create$VH.set(seg, x);
    }
    public static MemoryAddress create$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.create$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void create$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.create$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static create create (MemorySegment segment, ResourceScope scope) {
        return create.ofAddress(create$get(segment), scope);
    }
    static final FunctionDescriptor ftruncate$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ftruncate$MH = RuntimeHelper.downcallHandle(
        fuse_operations.ftruncate$FUNC, false
    );
    public interface ftruncate {

        int apply(jdk.incubator.foreign.MemoryAddress x0, long x1, jdk.incubator.foreign.MemoryAddress x2);
        static NativeSymbol allocate(ftruncate fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(ftruncate.class, fi, fuse_operations.ftruncate$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;JLjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static ftruncate ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("ftruncate::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, long x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)fuse_operations.ftruncate$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1, (jdk.incubator.foreign.Addressable)x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ftruncate$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ftruncate"));
    public static VarHandle ftruncate$VH() {
        return fuse_operations.ftruncate$VH;
    }
    public static MemoryAddress ftruncate$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.ftruncate$VH.get(seg);
    }
    public static void ftruncate$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.ftruncate$VH.set(seg, x);
    }
    public static MemoryAddress ftruncate$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.ftruncate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ftruncate$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.ftruncate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ftruncate ftruncate (MemorySegment segment, ResourceScope scope) {
        return ftruncate.ofAddress(ftruncate$get(segment), scope);
    }
    static final FunctionDescriptor fgetattr$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle fgetattr$MH = RuntimeHelper.downcallHandle(
        fuse_operations.fgetattr$FUNC, false
    );
    public interface fgetattr {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);
        static NativeSymbol allocate(fgetattr fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(fgetattr.class, fi, fuse_operations.fgetattr$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static fgetattr ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("fgetattr::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)fuse_operations.fgetattr$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, (jdk.incubator.foreign.Addressable)x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle fgetattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fgetattr"));
    public static VarHandle fgetattr$VH() {
        return fuse_operations.fgetattr$VH;
    }
    public static MemoryAddress fgetattr$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.fgetattr$VH.get(seg);
    }
    public static void fgetattr$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.fgetattr$VH.set(seg, x);
    }
    public static MemoryAddress fgetattr$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.fgetattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fgetattr$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.fgetattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static fgetattr fgetattr (MemorySegment segment, ResourceScope scope) {
        return fgetattr.ofAddress(fgetattr$get(segment), scope);
    }
    static final FunctionDescriptor lock$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle lock$MH = RuntimeHelper.downcallHandle(
        fuse_operations.lock$FUNC, false
    );
    public interface lock {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, int x2, jdk.incubator.foreign.MemoryAddress x3);
        static NativeSymbol allocate(lock fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(lock.class, fi, fuse_operations.lock$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static lock ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("lock::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, int x2, jdk.incubator.foreign.MemoryAddress x3) -> {
                try {
                    return (int)fuse_operations.lock$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, x2, (jdk.incubator.foreign.Addressable)x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle lock$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("lock"));
    public static VarHandle lock$VH() {
        return fuse_operations.lock$VH;
    }
    public static MemoryAddress lock$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.lock$VH.get(seg);
    }
    public static void lock$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.lock$VH.set(seg, x);
    }
    public static MemoryAddress lock$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.lock$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void lock$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.lock$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static lock lock (MemorySegment segment, ResourceScope scope) {
        return lock.ofAddress(lock$get(segment), scope);
    }
    static final FunctionDescriptor utimens$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle utimens$MH = RuntimeHelper.downcallHandle(
        fuse_operations.utimens$FUNC, false
    );
    public interface utimens {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(utimens fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(utimens.class, fi, fuse_operations.utimens$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static utimens ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("utimens::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.utimens$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle utimens$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("utimens"));
    public static VarHandle utimens$VH() {
        return fuse_operations.utimens$VH;
    }
    public static MemoryAddress utimens$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.utimens$VH.get(seg);
    }
    public static void utimens$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.utimens$VH.set(seg, x);
    }
    public static MemoryAddress utimens$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.utimens$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void utimens$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.utimens$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static utimens utimens (MemorySegment segment, ResourceScope scope) {
        return utimens.ofAddress(utimens$get(segment), scope);
    }
    static final FunctionDescriptor bmap$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle bmap$MH = RuntimeHelper.downcallHandle(
        fuse_operations.bmap$FUNC, false
    );
    public interface bmap {

        int apply(jdk.incubator.foreign.MemoryAddress x0, long x1, jdk.incubator.foreign.MemoryAddress x2);
        static NativeSymbol allocate(bmap fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(bmap.class, fi, fuse_operations.bmap$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;JLjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static bmap ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("bmap::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, long x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)fuse_operations.bmap$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1, (jdk.incubator.foreign.Addressable)x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle bmap$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("bmap"));
    public static VarHandle bmap$VH() {
        return fuse_operations.bmap$VH;
    }
    public static MemoryAddress bmap$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.bmap$VH.get(seg);
    }
    public static void bmap$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.bmap$VH.set(seg, x);
    }
    public static MemoryAddress bmap$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.bmap$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void bmap$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.bmap$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static bmap bmap (MemorySegment segment, ResourceScope scope) {
        return bmap.ofAddress(bmap$get(segment), scope);
    }
    static final FunctionDescriptor ioctl$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ioctl$MH = RuntimeHelper.downcallHandle(
        fuse_operations.ioctl$FUNC, false
    );
    public interface ioctl {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3, int x4, jdk.incubator.foreign.MemoryAddress x5);
        static NativeSymbol allocate(ioctl fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(ioctl.class, fi, fuse_operations.ioctl$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static ioctl ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("ioctl::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, int x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3, int x4, jdk.incubator.foreign.MemoryAddress x5) -> {
                try {
                    return (int)fuse_operations.ioctl$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1, (jdk.incubator.foreign.Addressable)x2, (jdk.incubator.foreign.Addressable)x3, x4, (jdk.incubator.foreign.Addressable)x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ioctl$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ioctl"));
    public static VarHandle ioctl$VH() {
        return fuse_operations.ioctl$VH;
    }
    public static MemoryAddress ioctl$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.ioctl$VH.get(seg);
    }
    public static void ioctl$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.ioctl$VH.set(seg, x);
    }
    public static MemoryAddress ioctl$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.ioctl$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ioctl$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.ioctl$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ioctl ioctl (MemorySegment segment, ResourceScope scope) {
        return ioctl.ofAddress(ioctl$get(segment), scope);
    }
    static final FunctionDescriptor poll$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle poll$MH = RuntimeHelper.downcallHandle(
        fuse_operations.poll$FUNC, false
    );
    public interface poll {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3);
        static NativeSymbol allocate(poll fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(poll.class, fi, fuse_operations.poll$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static poll ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("poll::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2, jdk.incubator.foreign.MemoryAddress x3) -> {
                try {
                    return (int)fuse_operations.poll$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, (jdk.incubator.foreign.Addressable)x2, (jdk.incubator.foreign.Addressable)x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle poll$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("poll"));
    public static VarHandle poll$VH() {
        return fuse_operations.poll$VH;
    }
    public static MemoryAddress poll$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.poll$VH.get(seg);
    }
    public static void poll$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.poll$VH.set(seg, x);
    }
    public static MemoryAddress poll$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.poll$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void poll$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.poll$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static poll poll (MemorySegment segment, ResourceScope scope) {
        return poll.ofAddress(poll$get(segment), scope);
    }
    static final FunctionDescriptor write_buf$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle write_buf$MH = RuntimeHelper.downcallHandle(
        fuse_operations.write_buf$FUNC, false
    );
    public interface write_buf {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, long x2, jdk.incubator.foreign.MemoryAddress x3);
        static NativeSymbol allocate(write_buf fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(write_buf.class, fi, fuse_operations.write_buf$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;JLjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static write_buf ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("write_buf::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, long x2, jdk.incubator.foreign.MemoryAddress x3) -> {
                try {
                    return (int)fuse_operations.write_buf$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, x2, (jdk.incubator.foreign.Addressable)x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle write_buf$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("write_buf"));
    public static VarHandle write_buf$VH() {
        return fuse_operations.write_buf$VH;
    }
    public static MemoryAddress write_buf$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.write_buf$VH.get(seg);
    }
    public static void write_buf$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.write_buf$VH.set(seg, x);
    }
    public static MemoryAddress write_buf$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.write_buf$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void write_buf$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.write_buf$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static write_buf write_buf (MemorySegment segment, ResourceScope scope) {
        return write_buf.ofAddress(write_buf$get(segment), scope);
    }
    static final FunctionDescriptor read_buf$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle read_buf$MH = RuntimeHelper.downcallHandle(
        fuse_operations.read_buf$FUNC, false
    );
    public interface read_buf {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, long x2, long x3, jdk.incubator.foreign.MemoryAddress x4);
        static NativeSymbol allocate(read_buf fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(read_buf.class, fi, fuse_operations.read_buf$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;JJLjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static read_buf ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("read_buf::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, long x2, long x3, jdk.incubator.foreign.MemoryAddress x4) -> {
                try {
                    return (int)fuse_operations.read_buf$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, x2, x3, (jdk.incubator.foreign.Addressable)x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle read_buf$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("read_buf"));
    public static VarHandle read_buf$VH() {
        return fuse_operations.read_buf$VH;
    }
    public static MemoryAddress read_buf$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.read_buf$VH.get(seg);
    }
    public static void read_buf$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.read_buf$VH.set(seg, x);
    }
    public static MemoryAddress read_buf$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.read_buf$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void read_buf$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.read_buf$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static read_buf read_buf (MemorySegment segment, ResourceScope scope) {
        return read_buf.ofAddress(read_buf$get(segment), scope);
    }
    static final FunctionDescriptor flock$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle flock$MH = RuntimeHelper.downcallHandle(
        fuse_operations.flock$FUNC, false
    );
    public interface flock {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, int x2);
        static NativeSymbol allocate(flock fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(flock.class, fi, fuse_operations.flock$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;I)I", scope);
        }
        static flock ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("flock::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, int x2) -> {
                try {
                    return (int)fuse_operations.flock$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle flock$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("flock"));
    public static VarHandle flock$VH() {
        return fuse_operations.flock$VH;
    }
    public static MemoryAddress flock$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.flock$VH.get(seg);
    }
    public static void flock$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.flock$VH.set(seg, x);
    }
    public static MemoryAddress flock$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.flock$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void flock$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.flock$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static flock flock (MemorySegment segment, ResourceScope scope) {
        return flock.ofAddress(flock$get(segment), scope);
    }
    static final FunctionDescriptor fallocate$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle fallocate$MH = RuntimeHelper.downcallHandle(
        fuse_operations.fallocate$FUNC, false
    );
    public interface fallocate {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, long x2, long x3, jdk.incubator.foreign.MemoryAddress x4);
        static NativeSymbol allocate(fallocate fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(fallocate.class, fi, fuse_operations.fallocate$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;IJJLjdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static fallocate ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("fallocate::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, int x1, long x2, long x3, jdk.incubator.foreign.MemoryAddress x4) -> {
                try {
                    return (int)fuse_operations.fallocate$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1, x2, x3, (jdk.incubator.foreign.Addressable)x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle fallocate$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fallocate"));
    public static VarHandle fallocate$VH() {
        return fuse_operations.fallocate$VH;
    }
    public static MemoryAddress fallocate$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.fallocate$VH.get(seg);
    }
    public static void fallocate$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.fallocate$VH.set(seg, x);
    }
    public static MemoryAddress fallocate$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.fallocate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fallocate$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.fallocate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static fallocate fallocate (MemorySegment segment, ResourceScope scope) {
        return fallocate.ofAddress(fallocate$get(segment), scope);
    }
    static final FunctionDescriptor reserved00$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT);
    static final MethodHandle reserved00$MH = RuntimeHelper.downcallHandle(
        fuse_operations.reserved00$FUNC, false
    );
    public interface reserved00 {

        int apply();
        static NativeSymbol allocate(reserved00 fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(reserved00.class, fi, fuse_operations.reserved00$FUNC, "()I", scope);
        }
        static reserved00 ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("reserved00::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    return (int)fuse_operations.reserved00$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle reserved00$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("reserved00"));
    public static VarHandle reserved00$VH() {
        return fuse_operations.reserved00$VH;
    }
    public static MemoryAddress reserved00$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.reserved00$VH.get(seg);
    }
    public static void reserved00$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.reserved00$VH.set(seg, x);
    }
    public static MemoryAddress reserved00$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.reserved00$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void reserved00$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.reserved00$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static reserved00 reserved00 (MemorySegment segment, ResourceScope scope) {
        return reserved00.ofAddress(reserved00$get(segment), scope);
    }
    static final FunctionDescriptor reserved01$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT);
    static final MethodHandle reserved01$MH = RuntimeHelper.downcallHandle(
        fuse_operations.reserved01$FUNC, false
    );
    public interface reserved01 {

        int apply();
        static NativeSymbol allocate(reserved01 fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(reserved01.class, fi, fuse_operations.reserved01$FUNC, "()I", scope);
        }
        static reserved01 ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("reserved01::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    return (int)fuse_operations.reserved01$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle reserved01$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("reserved01"));
    public static VarHandle reserved01$VH() {
        return fuse_operations.reserved01$VH;
    }
    public static MemoryAddress reserved01$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.reserved01$VH.get(seg);
    }
    public static void reserved01$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.reserved01$VH.set(seg, x);
    }
    public static MemoryAddress reserved01$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.reserved01$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void reserved01$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.reserved01$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static reserved01 reserved01 (MemorySegment segment, ResourceScope scope) {
        return reserved01.ofAddress(reserved01$get(segment), scope);
    }
    static final FunctionDescriptor reserved02$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT);
    static final MethodHandle reserved02$MH = RuntimeHelper.downcallHandle(
        fuse_operations.reserved02$FUNC, false
    );
    public interface reserved02 {

        int apply();
        static NativeSymbol allocate(reserved02 fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(reserved02.class, fi, fuse_operations.reserved02$FUNC, "()I", scope);
        }
        static reserved02 ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("reserved02::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    return (int)fuse_operations.reserved02$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle reserved02$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("reserved02"));
    public static VarHandle reserved02$VH() {
        return fuse_operations.reserved02$VH;
    }
    public static MemoryAddress reserved02$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.reserved02$VH.get(seg);
    }
    public static void reserved02$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.reserved02$VH.set(seg, x);
    }
    public static MemoryAddress reserved02$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.reserved02$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void reserved02$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.reserved02$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static reserved02 reserved02 (MemorySegment segment, ResourceScope scope) {
        return reserved02.ofAddress(reserved02$get(segment), scope);
    }
    static final FunctionDescriptor statfs_x$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle statfs_x$MH = RuntimeHelper.downcallHandle(
        fuse_operations.statfs_x$FUNC, false
    );
    public interface statfs_x {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(statfs_x fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(statfs_x.class, fi, fuse_operations.statfs_x$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static statfs_x ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("statfs_x::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.statfs_x$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle statfs_x$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("statfs_x"));
    public static VarHandle statfs_x$VH() {
        return fuse_operations.statfs_x$VH;
    }
    public static MemoryAddress statfs_x$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.statfs_x$VH.get(seg);
    }
    public static void statfs_x$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.statfs_x$VH.set(seg, x);
    }
    public static MemoryAddress statfs_x$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.statfs_x$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void statfs_x$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.statfs_x$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static statfs_x statfs_x (MemorySegment segment, ResourceScope scope) {
        return statfs_x.ofAddress(statfs_x$get(segment), scope);
    }
    static final FunctionDescriptor setvolname$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle setvolname$MH = RuntimeHelper.downcallHandle(
        fuse_operations.setvolname$FUNC, false
    );
    public interface setvolname {

        int apply(jdk.incubator.foreign.MemoryAddress x0);
        static NativeSymbol allocate(setvolname fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(setvolname.class, fi, fuse_operations.setvolname$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static setvolname ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("setvolname::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0) -> {
                try {
                    return (int)fuse_operations.setvolname$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle setvolname$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("setvolname"));
    public static VarHandle setvolname$VH() {
        return fuse_operations.setvolname$VH;
    }
    public static MemoryAddress setvolname$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.setvolname$VH.get(seg);
    }
    public static void setvolname$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.setvolname$VH.set(seg, x);
    }
    public static MemoryAddress setvolname$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.setvolname$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void setvolname$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.setvolname$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static setvolname setvolname (MemorySegment segment, ResourceScope scope) {
        return setvolname.ofAddress(setvolname$get(segment), scope);
    }
    static final FunctionDescriptor exchange$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle exchange$MH = RuntimeHelper.downcallHandle(
        fuse_operations.exchange$FUNC, false
    );
    public interface exchange {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, int x2);
        static NativeSymbol allocate(exchange fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(exchange.class, fi, fuse_operations.exchange$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;I)I", scope);
        }
        static exchange ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("exchange::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, int x2) -> {
                try {
                    return (int)fuse_operations.exchange$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle exchange$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("exchange"));
    public static VarHandle exchange$VH() {
        return fuse_operations.exchange$VH;
    }
    public static MemoryAddress exchange$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.exchange$VH.get(seg);
    }
    public static void exchange$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.exchange$VH.set(seg, x);
    }
    public static MemoryAddress exchange$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.exchange$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void exchange$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.exchange$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static exchange exchange (MemorySegment segment, ResourceScope scope) {
        return exchange.ofAddress(exchange$get(segment), scope);
    }
    static final FunctionDescriptor getxtimes$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle getxtimes$MH = RuntimeHelper.downcallHandle(
        fuse_operations.getxtimes$FUNC, false
    );
    public interface getxtimes {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);
        static NativeSymbol allocate(getxtimes fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(getxtimes.class, fi, fuse_operations.getxtimes$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static getxtimes ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("getxtimes::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)fuse_operations.getxtimes$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, (jdk.incubator.foreign.Addressable)x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle getxtimes$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("getxtimes"));
    public static VarHandle getxtimes$VH() {
        return fuse_operations.getxtimes$VH;
    }
    public static MemoryAddress getxtimes$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.getxtimes$VH.get(seg);
    }
    public static void getxtimes$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.getxtimes$VH.set(seg, x);
    }
    public static MemoryAddress getxtimes$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.getxtimes$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void getxtimes$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.getxtimes$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static getxtimes getxtimes (MemorySegment segment, ResourceScope scope) {
        return getxtimes.ofAddress(getxtimes$get(segment), scope);
    }
    static final FunctionDescriptor setbkuptime$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle setbkuptime$MH = RuntimeHelper.downcallHandle(
        fuse_operations.setbkuptime$FUNC, false
    );
    public interface setbkuptime {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(setbkuptime fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(setbkuptime.class, fi, fuse_operations.setbkuptime$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static setbkuptime ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("setbkuptime::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.setbkuptime$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle setbkuptime$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("setbkuptime"));
    public static VarHandle setbkuptime$VH() {
        return fuse_operations.setbkuptime$VH;
    }
    public static MemoryAddress setbkuptime$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.setbkuptime$VH.get(seg);
    }
    public static void setbkuptime$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.setbkuptime$VH.set(seg, x);
    }
    public static MemoryAddress setbkuptime$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.setbkuptime$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void setbkuptime$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.setbkuptime$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static setbkuptime setbkuptime (MemorySegment segment, ResourceScope scope) {
        return setbkuptime.ofAddress(setbkuptime$get(segment), scope);
    }
    static final FunctionDescriptor setchgtime$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle setchgtime$MH = RuntimeHelper.downcallHandle(
        fuse_operations.setchgtime$FUNC, false
    );
    public interface setchgtime {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(setchgtime fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(setchgtime.class, fi, fuse_operations.setchgtime$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static setchgtime ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("setchgtime::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.setchgtime$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle setchgtime$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("setchgtime"));
    public static VarHandle setchgtime$VH() {
        return fuse_operations.setchgtime$VH;
    }
    public static MemoryAddress setchgtime$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.setchgtime$VH.get(seg);
    }
    public static void setchgtime$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.setchgtime$VH.set(seg, x);
    }
    public static MemoryAddress setchgtime$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.setchgtime$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void setchgtime$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.setchgtime$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static setchgtime setchgtime (MemorySegment segment, ResourceScope scope) {
        return setchgtime.ofAddress(setchgtime$get(segment), scope);
    }
    static final FunctionDescriptor setcrtime$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle setcrtime$MH = RuntimeHelper.downcallHandle(
        fuse_operations.setcrtime$FUNC, false
    );
    public interface setcrtime {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(setcrtime fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(setcrtime.class, fi, fuse_operations.setcrtime$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static setcrtime ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("setcrtime::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.setcrtime$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle setcrtime$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("setcrtime"));
    public static VarHandle setcrtime$VH() {
        return fuse_operations.setcrtime$VH;
    }
    public static MemoryAddress setcrtime$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.setcrtime$VH.get(seg);
    }
    public static void setcrtime$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.setcrtime$VH.set(seg, x);
    }
    public static MemoryAddress setcrtime$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.setcrtime$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void setcrtime$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.setcrtime$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static setcrtime setcrtime (MemorySegment segment, ResourceScope scope) {
        return setcrtime.ofAddress(setcrtime$get(segment), scope);
    }
    static final FunctionDescriptor chflags$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG$LAYOUT
    );
    static final MethodHandle chflags$MH = RuntimeHelper.downcallHandle(
        fuse_operations.chflags$FUNC, false
    );
    public interface chflags {

        int apply(jdk.incubator.foreign.MemoryAddress x0, int x1);
        static NativeSymbol allocate(chflags fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(chflags.class, fi, fuse_operations.chflags$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)I", scope);
        }
        static chflags ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("chflags::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, int x1) -> {
                try {
                    return (int)fuse_operations.chflags$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle chflags$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("chflags"));
    public static VarHandle chflags$VH() {
        return fuse_operations.chflags$VH;
    }
    public static MemoryAddress chflags$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.chflags$VH.get(seg);
    }
    public static void chflags$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.chflags$VH.set(seg, x);
    }
    public static MemoryAddress chflags$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.chflags$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void chflags$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.chflags$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static chflags chflags (MemorySegment segment, ResourceScope scope) {
        return chflags.ofAddress(chflags$get(segment), scope);
    }
    static final FunctionDescriptor setattr_x$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle setattr_x$MH = RuntimeHelper.downcallHandle(
        fuse_operations.setattr_x$FUNC, false
    );
    public interface setattr_x {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1);
        static NativeSymbol allocate(setattr_x fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(setattr_x.class, fi, fuse_operations.setattr_x$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static setattr_x ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("setattr_x::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1) -> {
                try {
                    return (int)fuse_operations.setattr_x$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle setattr_x$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("setattr_x"));
    public static VarHandle setattr_x$VH() {
        return fuse_operations.setattr_x$VH;
    }
    public static MemoryAddress setattr_x$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.setattr_x$VH.get(seg);
    }
    public static void setattr_x$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.setattr_x$VH.set(seg, x);
    }
    public static MemoryAddress setattr_x$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.setattr_x$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void setattr_x$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.setattr_x$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static setattr_x setattr_x (MemorySegment segment, ResourceScope scope) {
        return setattr_x.ofAddress(setattr_x$get(segment), scope);
    }
    static final FunctionDescriptor fsetattr_x$FUNC = FunctionDescriptor.of(Constants$root.C_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle fsetattr_x$MH = RuntimeHelper.downcallHandle(
        fuse_operations.fsetattr_x$FUNC, false
    );
    public interface fsetattr_x {

        int apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2);
        static NativeSymbol allocate(fsetattr_x fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(fsetattr_x.class, fi, fuse_operations.fsetattr_x$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static fsetattr_x ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("fsetattr_x::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, jdk.incubator.foreign.MemoryAddress x2) -> {
                try {
                    return (int)fuse_operations.fsetattr_x$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, (jdk.incubator.foreign.Addressable)x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle fsetattr_x$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fsetattr_x"));
    public static VarHandle fsetattr_x$VH() {
        return fuse_operations.fsetattr_x$VH;
    }
    public static MemoryAddress fsetattr_x$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.fsetattr_x$VH.get(seg);
    }
    public static void fsetattr_x$set( MemorySegment seg, MemoryAddress x) {
        fuse_operations.fsetattr_x$VH.set(seg, x);
    }
    public static MemoryAddress fsetattr_x$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)fuse_operations.fsetattr_x$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fsetattr_x$set(MemorySegment seg, long index, MemoryAddress x) {
        fuse_operations.fsetattr_x$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static fsetattr_x fsetattr_x (MemorySegment segment, ResourceScope scope) {
        return fsetattr_x.ofAddress(fsetattr_x$get(segment), scope);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.nativeAllocator(scope)); }
    public static MemorySegment allocateArray(int len, ResourceScope scope) {
        return allocateArray(len, SegmentAllocator.nativeAllocator(scope));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


