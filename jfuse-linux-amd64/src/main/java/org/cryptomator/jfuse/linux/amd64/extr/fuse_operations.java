// Generated by jextract

package org.cryptomator.jfuse.linux.amd64.extr;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
/**
 * {@snippet :
 * struct fuse_operations {
 *     int (*getattr)(char*,struct stat*,struct fuse_file_info*);
 *     int (*readlink)(char*,char*,size_t);
 *     int (*mknod)(char*,mode_t,dev_t);
 *     int (*mkdir)(char*,mode_t);
 *     int (*unlink)(char*);
 *     int (*rmdir)(char*);
 *     int (*symlink)(char*,char*);
 *     int (*rename)(char*,char*,unsigned int);
 *     int (*link)(char*,char*);
 *     int (*chmod)(char*,mode_t,struct fuse_file_info*);
 *     int (*chown)(char*,uid_t,gid_t,struct fuse_file_info*);
 *     int (*truncate)(char*,off_t,struct fuse_file_info*);
 *     int (*open)(char*,struct fuse_file_info*);
 *     int (*read)(char*,char*,size_t,off_t,struct fuse_file_info*);
 *     int (*write)(char*,char*,size_t,off_t,struct fuse_file_info*);
 *     int (*statfs)(char*,struct statvfs*);
 *     int (*flush)(char*,struct fuse_file_info*);
 *     int (*release)(char*,struct fuse_file_info*);
 *     int (*fsync)(char*,int,struct fuse_file_info*);
 *     int (*setxattr)(char*,char*,char*,size_t,int);
 *     int (*getxattr)(char*,char*,char*,size_t);
 *     int (*listxattr)(char*,char*,size_t);
 *     int (*removexattr)(char*,char*);
 *     int (*opendir)(char*,struct fuse_file_info*);
 *     int (*readdir)(char*,void*,fuse_fill_dir_t,off_t,struct fuse_file_info*,enum fuse_readdir_flags);
 *     int (*releasedir)(char*,struct fuse_file_info*);
 *     int (*fsyncdir)(char*,int,struct fuse_file_info*);
 *     void* (*init)(struct fuse_conn_info*,struct fuse_config*);
 *     void (*destroy)(void*);
 *     int (*access)(char*,int);
 *     int (*create)(char*,mode_t,struct fuse_file_info*);
 *     int (*lock)(char*,struct fuse_file_info*,int,struct flock*);
 *     int (*utimens)(char*,struct timespec*,struct fuse_file_info*);
 *     int (*bmap)(char*,size_t,uint64_t*);
 *     int (*ioctl)(char*,unsigned int,void*,struct fuse_file_info*,unsigned int,void*);
 *     int (*poll)(char*,struct fuse_file_info*,struct fuse_pollhandle*,unsigned int*);
 *     int (*write_buf)(char*,struct fuse_bufvec*,off_t,struct fuse_file_info*);
 *     int (*read_buf)(char*,struct fuse_bufvec**,size_t,off_t,struct fuse_file_info*);
 *     int (*flock)(char*,struct fuse_file_info*,int);
 *     int (*fallocate)(char*,int,off_t,off_t,struct fuse_file_info*);
 *     ssize_t (*copy_file_range)(char*,struct fuse_file_info*,off_t,char*,struct fuse_file_info*,off_t,size_t,int);
 *     off_t (*lseek)(char*,off_t,int,struct fuse_file_info*);
 * };
 * }
 */
public class fuse_operations {

    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("getattr"),
        Constants$root.C_POINTER$LAYOUT.withName("readlink"),
        Constants$root.C_POINTER$LAYOUT.withName("mknod"),
        Constants$root.C_POINTER$LAYOUT.withName("mkdir"),
        Constants$root.C_POINTER$LAYOUT.withName("unlink"),
        Constants$root.C_POINTER$LAYOUT.withName("rmdir"),
        Constants$root.C_POINTER$LAYOUT.withName("symlink"),
        Constants$root.C_POINTER$LAYOUT.withName("rename"),
        Constants$root.C_POINTER$LAYOUT.withName("link"),
        Constants$root.C_POINTER$LAYOUT.withName("chmod"),
        Constants$root.C_POINTER$LAYOUT.withName("chown"),
        Constants$root.C_POINTER$LAYOUT.withName("truncate"),
        Constants$root.C_POINTER$LAYOUT.withName("open"),
        Constants$root.C_POINTER$LAYOUT.withName("read"),
        Constants$root.C_POINTER$LAYOUT.withName("write"),
        Constants$root.C_POINTER$LAYOUT.withName("statfs"),
        Constants$root.C_POINTER$LAYOUT.withName("flush"),
        Constants$root.C_POINTER$LAYOUT.withName("release"),
        Constants$root.C_POINTER$LAYOUT.withName("fsync"),
        Constants$root.C_POINTER$LAYOUT.withName("setxattr"),
        Constants$root.C_POINTER$LAYOUT.withName("getxattr"),
        Constants$root.C_POINTER$LAYOUT.withName("listxattr"),
        Constants$root.C_POINTER$LAYOUT.withName("removexattr"),
        Constants$root.C_POINTER$LAYOUT.withName("opendir"),
        Constants$root.C_POINTER$LAYOUT.withName("readdir"),
        Constants$root.C_POINTER$LAYOUT.withName("releasedir"),
        Constants$root.C_POINTER$LAYOUT.withName("fsyncdir"),
        Constants$root.C_POINTER$LAYOUT.withName("init"),
        Constants$root.C_POINTER$LAYOUT.withName("destroy"),
        Constants$root.C_POINTER$LAYOUT.withName("access"),
        Constants$root.C_POINTER$LAYOUT.withName("create"),
        Constants$root.C_POINTER$LAYOUT.withName("lock"),
        Constants$root.C_POINTER$LAYOUT.withName("utimens"),
        Constants$root.C_POINTER$LAYOUT.withName("bmap"),
        Constants$root.C_POINTER$LAYOUT.withName("ioctl"),
        Constants$root.C_POINTER$LAYOUT.withName("poll"),
        Constants$root.C_POINTER$LAYOUT.withName("write_buf"),
        Constants$root.C_POINTER$LAYOUT.withName("read_buf"),
        Constants$root.C_POINTER$LAYOUT.withName("flock"),
        Constants$root.C_POINTER$LAYOUT.withName("fallocate"),
        Constants$root.C_POINTER$LAYOUT.withName("copy_file_range"),
        Constants$root.C_POINTER$LAYOUT.withName("lseek")
    ).withName("fuse_operations");
    public static MemoryLayout $LAYOUT() {
        return fuse_operations.$struct$LAYOUT;
    }
    static final FunctionDescriptor getattr$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle getattr$MH = RuntimeHelper.downcallHandle(
        fuse_operations.getattr$FUNC
    );
    /**
     * {@snippet :
 * int (*getattr)(char*,struct stat*,struct fuse_file_info*);
     * }
     */
    public interface getattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(getattr fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(getattr.class, fi, fuse_operations.getattr$FUNC, scope);
        }
        static getattr ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse_operations.getattr$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle getattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("getattr"));
    public static VarHandle getattr$VH() {
        return fuse_operations.getattr$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*getattr)(char*,struct stat*,struct fuse_file_info*);
     * }
     */
    public static MemorySegment getattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.getattr$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*getattr)(char*,struct stat*,struct fuse_file_info*);
     * }
     */
    public static void getattr$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.getattr$VH.set(seg, x);
    }
    public static MemorySegment getattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.getattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void getattr$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.getattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static getattr getattr(MemorySegment segment, SegmentScope scope) {
        return getattr.ofAddress(getattr$get(segment), scope);
    }
    static final FunctionDescriptor readlink$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle readlink$MH = RuntimeHelper.downcallHandle(
        fuse_operations.readlink$FUNC
    );
    /**
     * {@snippet :
 * int (*readlink)(char*,char*,size_t);
     * }
     */
    public interface readlink {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2);
        static MemorySegment allocate(readlink fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(readlink.class, fi, fuse_operations.readlink$FUNC, scope);
        }
        static readlink ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2) -> {
                try {
                    return (int)fuse_operations.readlink$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle readlink$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("readlink"));
    public static VarHandle readlink$VH() {
        return fuse_operations.readlink$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*readlink)(char*,char*,size_t);
     * }
     */
    public static MemorySegment readlink$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.readlink$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*readlink)(char*,char*,size_t);
     * }
     */
    public static void readlink$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.readlink$VH.set(seg, x);
    }
    public static MemorySegment readlink$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.readlink$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void readlink$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.readlink$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static readlink readlink(MemorySegment segment, SegmentScope scope) {
        return readlink.ofAddress(readlink$get(segment), scope);
    }
    static final FunctionDescriptor mknod$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle mknod$MH = RuntimeHelper.downcallHandle(
        fuse_operations.mknod$FUNC
    );
    /**
     * {@snippet :
 * int (*mknod)(char*,mode_t,dev_t);
     * }
     */
    public interface mknod {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, long _x2);
        static MemorySegment allocate(mknod fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(mknod.class, fi, fuse_operations.mknod$FUNC, scope);
        }
        static mknod ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, long __x2) -> {
                try {
                    return (int)fuse_operations.mknod$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mknod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("mknod"));
    public static VarHandle mknod$VH() {
        return fuse_operations.mknod$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*mknod)(char*,mode_t,dev_t);
     * }
     */
    public static MemorySegment mknod$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.mknod$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*mknod)(char*,mode_t,dev_t);
     * }
     */
    public static void mknod$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.mknod$VH.set(seg, x);
    }
    public static MemorySegment mknod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.mknod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mknod$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.mknod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mknod mknod(MemorySegment segment, SegmentScope scope) {
        return mknod.ofAddress(mknod$get(segment), scope);
    }
    static final FunctionDescriptor mkdir$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle mkdir$MH = RuntimeHelper.downcallHandle(
        fuse_operations.mkdir$FUNC
    );
    /**
     * {@snippet :
 * int (*mkdir)(char*,mode_t);
     * }
     */
    public interface mkdir {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1);
        static MemorySegment allocate(mkdir fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(mkdir.class, fi, fuse_operations.mkdir$FUNC, scope);
        }
        static mkdir ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1) -> {
                try {
                    return (int)fuse_operations.mkdir$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mkdir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("mkdir"));
    public static VarHandle mkdir$VH() {
        return fuse_operations.mkdir$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*mkdir)(char*,mode_t);
     * }
     */
    public static MemorySegment mkdir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.mkdir$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*mkdir)(char*,mode_t);
     * }
     */
    public static void mkdir$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.mkdir$VH.set(seg, x);
    }
    public static MemorySegment mkdir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.mkdir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mkdir$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.mkdir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mkdir mkdir(MemorySegment segment, SegmentScope scope) {
        return mkdir.ofAddress(mkdir$get(segment), scope);
    }
    static final FunctionDescriptor unlink$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle unlink$MH = RuntimeHelper.downcallHandle(
        fuse_operations.unlink$FUNC
    );
    /**
     * {@snippet :
 * int (*unlink)(char*);
     * }
     */
    public interface unlink {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(unlink fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(unlink.class, fi, fuse_operations.unlink$FUNC, scope);
        }
        static unlink ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)fuse_operations.unlink$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle unlink$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("unlink"));
    public static VarHandle unlink$VH() {
        return fuse_operations.unlink$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*unlink)(char*);
     * }
     */
    public static MemorySegment unlink$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.unlink$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*unlink)(char*);
     * }
     */
    public static void unlink$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.unlink$VH.set(seg, x);
    }
    public static MemorySegment unlink$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.unlink$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void unlink$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.unlink$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static unlink unlink(MemorySegment segment, SegmentScope scope) {
        return unlink.ofAddress(unlink$get(segment), scope);
    }
    static final FunctionDescriptor rmdir$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle rmdir$MH = RuntimeHelper.downcallHandle(
        fuse_operations.rmdir$FUNC
    );
    /**
     * {@snippet :
 * int (*rmdir)(char*);
     * }
     */
    public interface rmdir {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(rmdir fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(rmdir.class, fi, fuse_operations.rmdir$FUNC, scope);
        }
        static rmdir ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)fuse_operations.rmdir$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle rmdir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("rmdir"));
    public static VarHandle rmdir$VH() {
        return fuse_operations.rmdir$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*rmdir)(char*);
     * }
     */
    public static MemorySegment rmdir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.rmdir$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*rmdir)(char*);
     * }
     */
    public static void rmdir$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.rmdir$VH.set(seg, x);
    }
    public static MemorySegment rmdir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.rmdir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void rmdir$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.rmdir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static rmdir rmdir(MemorySegment segment, SegmentScope scope) {
        return rmdir.ofAddress(rmdir$get(segment), scope);
    }
    static final FunctionDescriptor symlink$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle symlink$MH = RuntimeHelper.downcallHandle(
        fuse_operations.symlink$FUNC
    );
    /**
     * {@snippet :
 * int (*symlink)(char*,char*);
     * }
     */
    public interface symlink {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(symlink fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(symlink.class, fi, fuse_operations.symlink$FUNC, scope);
        }
        static symlink ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse_operations.symlink$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle symlink$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("symlink"));
    public static VarHandle symlink$VH() {
        return fuse_operations.symlink$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*symlink)(char*,char*);
     * }
     */
    public static MemorySegment symlink$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.symlink$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*symlink)(char*,char*);
     * }
     */
    public static void symlink$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.symlink$VH.set(seg, x);
    }
    public static MemorySegment symlink$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.symlink$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void symlink$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.symlink$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static symlink symlink(MemorySegment segment, SegmentScope scope) {
        return symlink.ofAddress(symlink$get(segment), scope);
    }
    static final FunctionDescriptor rename$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle rename$MH = RuntimeHelper.downcallHandle(
        fuse_operations.rename$FUNC
    );
    /**
     * {@snippet :
 * int (*rename)(char*,char*,unsigned int);
     * }
     */
    public interface rename {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, int _x2);
        static MemorySegment allocate(rename fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(rename.class, fi, fuse_operations.rename$FUNC, scope);
        }
        static rename ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, int __x2) -> {
                try {
                    return (int)fuse_operations.rename$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle rename$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("rename"));
    public static VarHandle rename$VH() {
        return fuse_operations.rename$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*rename)(char*,char*,unsigned int);
     * }
     */
    public static MemorySegment rename$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.rename$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*rename)(char*,char*,unsigned int);
     * }
     */
    public static void rename$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.rename$VH.set(seg, x);
    }
    public static MemorySegment rename$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.rename$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void rename$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.rename$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static rename rename(MemorySegment segment, SegmentScope scope) {
        return rename.ofAddress(rename$get(segment), scope);
    }
    static final FunctionDescriptor link$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle link$MH = RuntimeHelper.downcallHandle(
        fuse_operations.link$FUNC
    );
    /**
     * {@snippet :
 * int (*link)(char*,char*);
     * }
     */
    public interface link {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(link fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(link.class, fi, fuse_operations.link$FUNC, scope);
        }
        static link ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse_operations.link$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle link$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("link"));
    public static VarHandle link$VH() {
        return fuse_operations.link$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*link)(char*,char*);
     * }
     */
    public static MemorySegment link$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.link$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*link)(char*,char*);
     * }
     */
    public static void link$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.link$VH.set(seg, x);
    }
    public static MemorySegment link$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.link$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void link$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.link$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static link link(MemorySegment segment, SegmentScope scope) {
        return link.ofAddress(link$get(segment), scope);
    }
    static final FunctionDescriptor chmod$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle chmod$MH = RuntimeHelper.downcallHandle(
        fuse_operations.chmod$FUNC
    );
    /**
     * {@snippet :
 * int (*chmod)(char*,mode_t,struct fuse_file_info*);
     * }
     */
    public interface chmod {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(chmod fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(chmod.class, fi, fuse_operations.chmod$FUNC, scope);
        }
        static chmod ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse_operations.chmod$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle chmod$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("chmod"));
    public static VarHandle chmod$VH() {
        return fuse_operations.chmod$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*chmod)(char*,mode_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment chmod$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.chmod$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*chmod)(char*,mode_t,struct fuse_file_info*);
     * }
     */
    public static void chmod$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.chmod$VH.set(seg, x);
    }
    public static MemorySegment chmod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.chmod$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void chmod$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.chmod$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static chmod chmod(MemorySegment segment, SegmentScope scope) {
        return chmod.ofAddress(chmod$get(segment), scope);
    }
    static final FunctionDescriptor chown$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle chown$MH = RuntimeHelper.downcallHandle(
        fuse_operations.chown$FUNC
    );
    /**
     * {@snippet :
 * int (*chown)(char*,uid_t,gid_t,struct fuse_file_info*);
     * }
     */
    public interface chown {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, int _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(chown fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(chown.class, fi, fuse_operations.chown$FUNC, scope);
        }
        static chown ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, int __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    return (int)fuse_operations.chown$MH.invokeExact(symbol, __x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle chown$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("chown"));
    public static VarHandle chown$VH() {
        return fuse_operations.chown$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*chown)(char*,uid_t,gid_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment chown$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.chown$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*chown)(char*,uid_t,gid_t,struct fuse_file_info*);
     * }
     */
    public static void chown$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.chown$VH.set(seg, x);
    }
    public static MemorySegment chown$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.chown$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void chown$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.chown$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static chown chown(MemorySegment segment, SegmentScope scope) {
        return chown.ofAddress(chown$get(segment), scope);
    }
    static final FunctionDescriptor truncate$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle truncate$MH = RuntimeHelper.downcallHandle(
        fuse_operations.truncate$FUNC
    );
    /**
     * {@snippet :
 * int (*truncate)(char*,off_t,struct fuse_file_info*);
     * }
     */
    public interface truncate {

        int apply(java.lang.foreign.MemorySegment _x0, long _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(truncate fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(truncate.class, fi, fuse_operations.truncate$FUNC, scope);
        }
        static truncate ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, long __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse_operations.truncate$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle truncate$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("truncate"));
    public static VarHandle truncate$VH() {
        return fuse_operations.truncate$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*truncate)(char*,off_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment truncate$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.truncate$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*truncate)(char*,off_t,struct fuse_file_info*);
     * }
     */
    public static void truncate$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.truncate$VH.set(seg, x);
    }
    public static MemorySegment truncate$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.truncate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void truncate$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.truncate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static truncate truncate(MemorySegment segment, SegmentScope scope) {
        return truncate.ofAddress(truncate$get(segment), scope);
    }
    static final FunctionDescriptor open$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle open$MH = RuntimeHelper.downcallHandle(
        fuse_operations.open$FUNC
    );
    /**
     * {@snippet :
 * int (*open)(char*,struct fuse_file_info*);
     * }
     */
    public interface open {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(open fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(open.class, fi, fuse_operations.open$FUNC, scope);
        }
        static open ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse_operations.open$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle open$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("open"));
    public static VarHandle open$VH() {
        return fuse_operations.open$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*open)(char*,struct fuse_file_info*);
     * }
     */
    public static MemorySegment open$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.open$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*open)(char*,struct fuse_file_info*);
     * }
     */
    public static void open$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.open$VH.set(seg, x);
    }
    public static MemorySegment open$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.open$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void open$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.open$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static open open(MemorySegment segment, SegmentScope scope) {
        return open.ofAddress(open$get(segment), scope);
    }
    static final FunctionDescriptor read$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle read$MH = RuntimeHelper.downcallHandle(
        fuse_operations.read$FUNC
    );
    /**
     * {@snippet :
 * int (*read)(char*,char*,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public interface read {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2, long _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(read fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(read.class, fi, fuse_operations.read$FUNC, scope);
        }
        static read ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2, long __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)fuse_operations.read$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle read$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("read"));
    public static VarHandle read$VH() {
        return fuse_operations.read$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*read)(char*,char*,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment read$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.read$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*read)(char*,char*,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public static void read$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.read$VH.set(seg, x);
    }
    public static MemorySegment read$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.read$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void read$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.read$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static read read(MemorySegment segment, SegmentScope scope) {
        return read.ofAddress(read$get(segment), scope);
    }
    static final FunctionDescriptor write$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle write$MH = RuntimeHelper.downcallHandle(
        fuse_operations.write$FUNC
    );
    /**
     * {@snippet :
 * int (*write)(char*,char*,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public interface write {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2, long _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(write fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(write.class, fi, fuse_operations.write$FUNC, scope);
        }
        static write ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2, long __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)fuse_operations.write$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle write$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("write"));
    public static VarHandle write$VH() {
        return fuse_operations.write$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*write)(char*,char*,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment write$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.write$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*write)(char*,char*,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public static void write$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.write$VH.set(seg, x);
    }
    public static MemorySegment write$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.write$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void write$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.write$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static write write(MemorySegment segment, SegmentScope scope) {
        return write.ofAddress(write$get(segment), scope);
    }
    static final FunctionDescriptor statfs$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle statfs$MH = RuntimeHelper.downcallHandle(
        fuse_operations.statfs$FUNC
    );
    /**
     * {@snippet :
 * int (*statfs)(char*,struct statvfs*);
     * }
     */
    public interface statfs {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(statfs fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(statfs.class, fi, fuse_operations.statfs$FUNC, scope);
        }
        static statfs ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse_operations.statfs$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle statfs$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("statfs"));
    public static VarHandle statfs$VH() {
        return fuse_operations.statfs$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*statfs)(char*,struct statvfs*);
     * }
     */
    public static MemorySegment statfs$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.statfs$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*statfs)(char*,struct statvfs*);
     * }
     */
    public static void statfs$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.statfs$VH.set(seg, x);
    }
    public static MemorySegment statfs$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.statfs$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void statfs$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.statfs$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static statfs statfs(MemorySegment segment, SegmentScope scope) {
        return statfs.ofAddress(statfs$get(segment), scope);
    }
    static final FunctionDescriptor flush$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle flush$MH = RuntimeHelper.downcallHandle(
        fuse_operations.flush$FUNC
    );
    /**
     * {@snippet :
 * int (*flush)(char*,struct fuse_file_info*);
     * }
     */
    public interface flush {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(flush fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(flush.class, fi, fuse_operations.flush$FUNC, scope);
        }
        static flush ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse_operations.flush$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle flush$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("flush"));
    public static VarHandle flush$VH() {
        return fuse_operations.flush$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*flush)(char*,struct fuse_file_info*);
     * }
     */
    public static MemorySegment flush$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.flush$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*flush)(char*,struct fuse_file_info*);
     * }
     */
    public static void flush$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.flush$VH.set(seg, x);
    }
    public static MemorySegment flush$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.flush$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void flush$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.flush$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static flush flush(MemorySegment segment, SegmentScope scope) {
        return flush.ofAddress(flush$get(segment), scope);
    }
    static final FunctionDescriptor release$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle release$MH = RuntimeHelper.downcallHandle(
        fuse_operations.release$FUNC
    );
    /**
     * {@snippet :
 * int (*release)(char*,struct fuse_file_info*);
     * }
     */
    public interface release {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(release fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(release.class, fi, fuse_operations.release$FUNC, scope);
        }
        static release ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse_operations.release$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle release$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("release"));
    public static VarHandle release$VH() {
        return fuse_operations.release$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*release)(char*,struct fuse_file_info*);
     * }
     */
    public static MemorySegment release$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.release$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*release)(char*,struct fuse_file_info*);
     * }
     */
    public static void release$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.release$VH.set(seg, x);
    }
    public static MemorySegment release$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.release$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void release$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.release$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static release release(MemorySegment segment, SegmentScope scope) {
        return release.ofAddress(release$get(segment), scope);
    }
    static final FunctionDescriptor fsync$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle fsync$MH = RuntimeHelper.downcallHandle(
        fuse_operations.fsync$FUNC
    );
    /**
     * {@snippet :
 * int (*fsync)(char*,int,struct fuse_file_info*);
     * }
     */
    public interface fsync {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(fsync fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(fsync.class, fi, fuse_operations.fsync$FUNC, scope);
        }
        static fsync ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse_operations.fsync$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle fsync$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fsync"));
    public static VarHandle fsync$VH() {
        return fuse_operations.fsync$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*fsync)(char*,int,struct fuse_file_info*);
     * }
     */
    public static MemorySegment fsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.fsync$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*fsync)(char*,int,struct fuse_file_info*);
     * }
     */
    public static void fsync$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.fsync$VH.set(seg, x);
    }
    public static MemorySegment fsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.fsync$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fsync$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.fsync$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static fsync fsync(MemorySegment segment, SegmentScope scope) {
        return fsync.ofAddress(fsync$get(segment), scope);
    }
    static final FunctionDescriptor setxattr$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle setxattr$MH = RuntimeHelper.downcallHandle(
        fuse_operations.setxattr$FUNC
    );
    /**
     * {@snippet :
 * int (*setxattr)(char*,char*,char*,size_t,int);
     * }
     */
    public interface setxattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, long _x3, int _x4);
        static MemorySegment allocate(setxattr fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(setxattr.class, fi, fuse_operations.setxattr$FUNC, scope);
        }
        static setxattr ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, long __x3, int __x4) -> {
                try {
                    return (int)fuse_operations.setxattr$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle setxattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("setxattr"));
    public static VarHandle setxattr$VH() {
        return fuse_operations.setxattr$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*setxattr)(char*,char*,char*,size_t,int);
     * }
     */
    public static MemorySegment setxattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.setxattr$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*setxattr)(char*,char*,char*,size_t,int);
     * }
     */
    public static void setxattr$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.setxattr$VH.set(seg, x);
    }
    public static MemorySegment setxattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.setxattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void setxattr$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.setxattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static setxattr setxattr(MemorySegment segment, SegmentScope scope) {
        return setxattr.ofAddress(setxattr$get(segment), scope);
    }
    static final FunctionDescriptor getxattr$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle getxattr$MH = RuntimeHelper.downcallHandle(
        fuse_operations.getxattr$FUNC
    );
    /**
     * {@snippet :
 * int (*getxattr)(char*,char*,char*,size_t);
     * }
     */
    public interface getxattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, long _x3);
        static MemorySegment allocate(getxattr fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(getxattr.class, fi, fuse_operations.getxattr$FUNC, scope);
        }
        static getxattr ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, long __x3) -> {
                try {
                    return (int)fuse_operations.getxattr$MH.invokeExact(symbol, __x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle getxattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("getxattr"));
    public static VarHandle getxattr$VH() {
        return fuse_operations.getxattr$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*getxattr)(char*,char*,char*,size_t);
     * }
     */
    public static MemorySegment getxattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.getxattr$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*getxattr)(char*,char*,char*,size_t);
     * }
     */
    public static void getxattr$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.getxattr$VH.set(seg, x);
    }
    public static MemorySegment getxattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.getxattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void getxattr$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.getxattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static getxattr getxattr(MemorySegment segment, SegmentScope scope) {
        return getxattr.ofAddress(getxattr$get(segment), scope);
    }
    static final FunctionDescriptor listxattr$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT
    );
    static final MethodHandle listxattr$MH = RuntimeHelper.downcallHandle(
        fuse_operations.listxattr$FUNC
    );
    /**
     * {@snippet :
 * int (*listxattr)(char*,char*,size_t);
     * }
     */
    public interface listxattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2);
        static MemorySegment allocate(listxattr fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(listxattr.class, fi, fuse_operations.listxattr$FUNC, scope);
        }
        static listxattr ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2) -> {
                try {
                    return (int)fuse_operations.listxattr$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle listxattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("listxattr"));
    public static VarHandle listxattr$VH() {
        return fuse_operations.listxattr$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*listxattr)(char*,char*,size_t);
     * }
     */
    public static MemorySegment listxattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.listxattr$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*listxattr)(char*,char*,size_t);
     * }
     */
    public static void listxattr$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.listxattr$VH.set(seg, x);
    }
    public static MemorySegment listxattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.listxattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void listxattr$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.listxattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static listxattr listxattr(MemorySegment segment, SegmentScope scope) {
        return listxattr.ofAddress(listxattr$get(segment), scope);
    }
    static final FunctionDescriptor removexattr$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle removexattr$MH = RuntimeHelper.downcallHandle(
        fuse_operations.removexattr$FUNC
    );
    /**
     * {@snippet :
 * int (*removexattr)(char*,char*);
     * }
     */
    public interface removexattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(removexattr fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(removexattr.class, fi, fuse_operations.removexattr$FUNC, scope);
        }
        static removexattr ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse_operations.removexattr$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle removexattr$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("removexattr"));
    public static VarHandle removexattr$VH() {
        return fuse_operations.removexattr$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*removexattr)(char*,char*);
     * }
     */
    public static MemorySegment removexattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.removexattr$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*removexattr)(char*,char*);
     * }
     */
    public static void removexattr$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.removexattr$VH.set(seg, x);
    }
    public static MemorySegment removexattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.removexattr$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void removexattr$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.removexattr$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static removexattr removexattr(MemorySegment segment, SegmentScope scope) {
        return removexattr.ofAddress(removexattr$get(segment), scope);
    }
    static final FunctionDescriptor opendir$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle opendir$MH = RuntimeHelper.downcallHandle(
        fuse_operations.opendir$FUNC
    );
    /**
     * {@snippet :
 * int (*opendir)(char*,struct fuse_file_info*);
     * }
     */
    public interface opendir {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(opendir fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(opendir.class, fi, fuse_operations.opendir$FUNC, scope);
        }
        static opendir ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse_operations.opendir$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle opendir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("opendir"));
    public static VarHandle opendir$VH() {
        return fuse_operations.opendir$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*opendir)(char*,struct fuse_file_info*);
     * }
     */
    public static MemorySegment opendir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.opendir$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*opendir)(char*,struct fuse_file_info*);
     * }
     */
    public static void opendir$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.opendir$VH.set(seg, x);
    }
    public static MemorySegment opendir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.opendir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void opendir$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.opendir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static opendir opendir(MemorySegment segment, SegmentScope scope) {
        return opendir.ofAddress(opendir$get(segment), scope);
    }
    static final FunctionDescriptor readdir$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle readdir$MH = RuntimeHelper.downcallHandle(
        fuse_operations.readdir$FUNC
    );
    /**
     * {@snippet :
 * int (*readdir)(char*,void*,fuse_fill_dir_t,off_t,struct fuse_file_info*,enum fuse_readdir_flags);
     * }
     */
    public interface readdir {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, long _x3, java.lang.foreign.MemorySegment _x4, int _x5);
        static MemorySegment allocate(readdir fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(readdir.class, fi, fuse_operations.readdir$FUNC, scope);
        }
        static readdir ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, long __x3, java.lang.foreign.MemorySegment __x4, int __x5) -> {
                try {
                    return (int)fuse_operations.readdir$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4, __x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle readdir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("readdir"));
    public static VarHandle readdir$VH() {
        return fuse_operations.readdir$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*readdir)(char*,void*,fuse_fill_dir_t,off_t,struct fuse_file_info*,enum fuse_readdir_flags);
     * }
     */
    public static MemorySegment readdir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.readdir$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*readdir)(char*,void*,fuse_fill_dir_t,off_t,struct fuse_file_info*,enum fuse_readdir_flags);
     * }
     */
    public static void readdir$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.readdir$VH.set(seg, x);
    }
    public static MemorySegment readdir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.readdir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void readdir$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.readdir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static readdir readdir(MemorySegment segment, SegmentScope scope) {
        return readdir.ofAddress(readdir$get(segment), scope);
    }
    static final FunctionDescriptor releasedir$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle releasedir$MH = RuntimeHelper.downcallHandle(
        fuse_operations.releasedir$FUNC
    );
    /**
     * {@snippet :
 * int (*releasedir)(char*,struct fuse_file_info*);
     * }
     */
    public interface releasedir {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(releasedir fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(releasedir.class, fi, fuse_operations.releasedir$FUNC, scope);
        }
        static releasedir ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)fuse_operations.releasedir$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle releasedir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("releasedir"));
    public static VarHandle releasedir$VH() {
        return fuse_operations.releasedir$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*releasedir)(char*,struct fuse_file_info*);
     * }
     */
    public static MemorySegment releasedir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.releasedir$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*releasedir)(char*,struct fuse_file_info*);
     * }
     */
    public static void releasedir$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.releasedir$VH.set(seg, x);
    }
    public static MemorySegment releasedir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.releasedir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void releasedir$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.releasedir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static releasedir releasedir(MemorySegment segment, SegmentScope scope) {
        return releasedir.ofAddress(releasedir$get(segment), scope);
    }
    static final FunctionDescriptor fsyncdir$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle fsyncdir$MH = RuntimeHelper.downcallHandle(
        fuse_operations.fsyncdir$FUNC
    );
    /**
     * {@snippet :
 * int (*fsyncdir)(char*,int,struct fuse_file_info*);
     * }
     */
    public interface fsyncdir {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(fsyncdir fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(fsyncdir.class, fi, fuse_operations.fsyncdir$FUNC, scope);
        }
        static fsyncdir ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse_operations.fsyncdir$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle fsyncdir$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fsyncdir"));
    public static VarHandle fsyncdir$VH() {
        return fuse_operations.fsyncdir$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*fsyncdir)(char*,int,struct fuse_file_info*);
     * }
     */
    public static MemorySegment fsyncdir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.fsyncdir$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*fsyncdir)(char*,int,struct fuse_file_info*);
     * }
     */
    public static void fsyncdir$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.fsyncdir$VH.set(seg, x);
    }
    public static MemorySegment fsyncdir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.fsyncdir$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fsyncdir$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.fsyncdir$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static fsyncdir fsyncdir(MemorySegment segment, SegmentScope scope) {
        return fsyncdir.ofAddress(fsyncdir$get(segment), scope);
    }
    static final FunctionDescriptor init$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle init$MH = RuntimeHelper.downcallHandle(
        fuse_operations.init$FUNC
    );
    /**
     * {@snippet :
 * void* (*init)(struct fuse_conn_info*,struct fuse_config*);
     * }
     */
    public interface init {

        java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(init fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(init.class, fi, fuse_operations.init$FUNC, scope);
        }
        static init ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (java.lang.foreign.MemorySegment)fuse_operations.init$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle init$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("init"));
    public static VarHandle init$VH() {
        return fuse_operations.init$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * void* (*init)(struct fuse_conn_info*,struct fuse_config*);
     * }
     */
    public static MemorySegment init$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.init$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * void* (*init)(struct fuse_conn_info*,struct fuse_config*);
     * }
     */
    public static void init$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.init$VH.set(seg, x);
    }
    public static MemorySegment init$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.init$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void init$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.init$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static init init(MemorySegment segment, SegmentScope scope) {
        return init.ofAddress(init$get(segment), scope);
    }
    static final FunctionDescriptor destroy$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle destroy$MH = RuntimeHelper.downcallHandle(
        fuse_operations.destroy$FUNC
    );
    /**
     * {@snippet :
 * void (*destroy)(void*);
     * }
     */
    public interface destroy {

        void apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(destroy fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(destroy.class, fi, fuse_operations.destroy$FUNC, scope);
        }
        static destroy ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    fuse_operations.destroy$MH.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle destroy$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("destroy"));
    public static VarHandle destroy$VH() {
        return fuse_operations.destroy$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * void (*destroy)(void*);
     * }
     */
    public static MemorySegment destroy$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.destroy$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * void (*destroy)(void*);
     * }
     */
    public static void destroy$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.destroy$VH.set(seg, x);
    }
    public static MemorySegment destroy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.destroy$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void destroy$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.destroy$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static destroy destroy(MemorySegment segment, SegmentScope scope) {
        return destroy.ofAddress(destroy$get(segment), scope);
    }
    static final FunctionDescriptor access$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle access$MH = RuntimeHelper.downcallHandle(
        fuse_operations.access$FUNC
    );
    /**
     * {@snippet :
 * int (*access)(char*,int);
     * }
     */
    public interface access {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1);
        static MemorySegment allocate(access fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(access.class, fi, fuse_operations.access$FUNC, scope);
        }
        static access ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1) -> {
                try {
                    return (int)fuse_operations.access$MH.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle access$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("access"));
    public static VarHandle access$VH() {
        return fuse_operations.access$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*access)(char*,int);
     * }
     */
    public static MemorySegment access$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.access$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*access)(char*,int);
     * }
     */
    public static void access$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.access$VH.set(seg, x);
    }
    public static MemorySegment access$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.access$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void access$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.access$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static access access(MemorySegment segment, SegmentScope scope) {
        return access.ofAddress(access$get(segment), scope);
    }
    static final FunctionDescriptor create$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle create$MH = RuntimeHelper.downcallHandle(
        fuse_operations.create$FUNC
    );
    /**
     * {@snippet :
 * int (*create)(char*,mode_t,struct fuse_file_info*);
     * }
     */
    public interface create {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(create fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(create.class, fi, fuse_operations.create$FUNC, scope);
        }
        static create ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse_operations.create$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle create$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("create"));
    public static VarHandle create$VH() {
        return fuse_operations.create$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*create)(char*,mode_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment create$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.create$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*create)(char*,mode_t,struct fuse_file_info*);
     * }
     */
    public static void create$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.create$VH.set(seg, x);
    }
    public static MemorySegment create$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.create$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void create$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.create$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static create create(MemorySegment segment, SegmentScope scope) {
        return create.ofAddress(create$get(segment), scope);
    }
    static final FunctionDescriptor lock$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle lock$MH = RuntimeHelper.downcallHandle(
        fuse_operations.lock$FUNC
    );
    /**
     * {@snippet :
 * int (*lock)(char*,struct fuse_file_info*,int,struct flock*);
     * }
     */
    public interface lock {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, int _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(lock fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(lock.class, fi, fuse_operations.lock$FUNC, scope);
        }
        static lock ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, int __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    return (int)fuse_operations.lock$MH.invokeExact(symbol, __x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle lock$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("lock"));
    public static VarHandle lock$VH() {
        return fuse_operations.lock$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*lock)(char*,struct fuse_file_info*,int,struct flock*);
     * }
     */
    public static MemorySegment lock$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.lock$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*lock)(char*,struct fuse_file_info*,int,struct flock*);
     * }
     */
    public static void lock$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.lock$VH.set(seg, x);
    }
    public static MemorySegment lock$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.lock$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void lock$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.lock$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static lock lock(MemorySegment segment, SegmentScope scope) {
        return lock.ofAddress(lock$get(segment), scope);
    }
    static final FunctionDescriptor utimens$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle utimens$MH = RuntimeHelper.downcallHandle(
        fuse_operations.utimens$FUNC
    );
    /**
     * {@snippet :
 * int (*utimens)(char*,struct timespec*,struct fuse_file_info*);
     * }
     */
    public interface utimens {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(utimens fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(utimens.class, fi, fuse_operations.utimens$FUNC, scope);
        }
        static utimens ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse_operations.utimens$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle utimens$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("utimens"));
    public static VarHandle utimens$VH() {
        return fuse_operations.utimens$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*utimens)(char*,struct timespec*,struct fuse_file_info*);
     * }
     */
    public static MemorySegment utimens$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.utimens$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*utimens)(char*,struct timespec*,struct fuse_file_info*);
     * }
     */
    public static void utimens$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.utimens$VH.set(seg, x);
    }
    public static MemorySegment utimens$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.utimens$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void utimens$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.utimens$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static utimens utimens(MemorySegment segment, SegmentScope scope) {
        return utimens.ofAddress(utimens$get(segment), scope);
    }
    static final FunctionDescriptor bmap$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle bmap$MH = RuntimeHelper.downcallHandle(
        fuse_operations.bmap$FUNC
    );
    /**
     * {@snippet :
 * int (*bmap)(char*,size_t,uint64_t*);
     * }
     */
    public interface bmap {

        int apply(java.lang.foreign.MemorySegment _x0, long _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(bmap fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(bmap.class, fi, fuse_operations.bmap$FUNC, scope);
        }
        static bmap ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, long __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)fuse_operations.bmap$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle bmap$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("bmap"));
    public static VarHandle bmap$VH() {
        return fuse_operations.bmap$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*bmap)(char*,size_t,uint64_t*);
     * }
     */
    public static MemorySegment bmap$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.bmap$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*bmap)(char*,size_t,uint64_t*);
     * }
     */
    public static void bmap$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.bmap$VH.set(seg, x);
    }
    public static MemorySegment bmap$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.bmap$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void bmap$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.bmap$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static bmap bmap(MemorySegment segment, SegmentScope scope) {
        return bmap.ofAddress(bmap$get(segment), scope);
    }
    static final FunctionDescriptor ioctl$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle ioctl$MH = RuntimeHelper.downcallHandle(
        fuse_operations.ioctl$FUNC
    );
    /**
     * {@snippet :
 * int (*ioctl)(char*,unsigned int,void*,struct fuse_file_info*,unsigned int,void*);
     * }
     */
    public interface ioctl {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3, int _x4, java.lang.foreign.MemorySegment _x5);
        static MemorySegment allocate(ioctl fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(ioctl.class, fi, fuse_operations.ioctl$FUNC, scope);
        }
        static ioctl ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3, int __x4, java.lang.foreign.MemorySegment __x5) -> {
                try {
                    return (int)fuse_operations.ioctl$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4, __x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle ioctl$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("ioctl"));
    public static VarHandle ioctl$VH() {
        return fuse_operations.ioctl$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*ioctl)(char*,unsigned int,void*,struct fuse_file_info*,unsigned int,void*);
     * }
     */
    public static MemorySegment ioctl$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.ioctl$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*ioctl)(char*,unsigned int,void*,struct fuse_file_info*,unsigned int,void*);
     * }
     */
    public static void ioctl$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.ioctl$VH.set(seg, x);
    }
    public static MemorySegment ioctl$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.ioctl$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void ioctl$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.ioctl$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static ioctl ioctl(MemorySegment segment, SegmentScope scope) {
        return ioctl.ofAddress(ioctl$get(segment), scope);
    }
    static final FunctionDescriptor poll$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle poll$MH = RuntimeHelper.downcallHandle(
        fuse_operations.poll$FUNC
    );
    /**
     * {@snippet :
 * int (*poll)(char*,struct fuse_file_info*,struct fuse_pollhandle*,unsigned int*);
     * }
     */
    public interface poll {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(poll fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(poll.class, fi, fuse_operations.poll$FUNC, scope);
        }
        static poll ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    return (int)fuse_operations.poll$MH.invokeExact(symbol, __x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle poll$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("poll"));
    public static VarHandle poll$VH() {
        return fuse_operations.poll$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*poll)(char*,struct fuse_file_info*,struct fuse_pollhandle*,unsigned int*);
     * }
     */
    public static MemorySegment poll$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.poll$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*poll)(char*,struct fuse_file_info*,struct fuse_pollhandle*,unsigned int*);
     * }
     */
    public static void poll$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.poll$VH.set(seg, x);
    }
    public static MemorySegment poll$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.poll$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void poll$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.poll$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static poll poll(MemorySegment segment, SegmentScope scope) {
        return poll.ofAddress(poll$get(segment), scope);
    }
    static final FunctionDescriptor write_buf$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle write_buf$MH = RuntimeHelper.downcallHandle(
        fuse_operations.write_buf$FUNC
    );
    /**
     * {@snippet :
 * int (*write_buf)(char*,struct fuse_bufvec*,off_t,struct fuse_file_info*);
     * }
     */
    public interface write_buf {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(write_buf fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(write_buf.class, fi, fuse_operations.write_buf$FUNC, scope);
        }
        static write_buf ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    return (int)fuse_operations.write_buf$MH.invokeExact(symbol, __x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle write_buf$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("write_buf"));
    public static VarHandle write_buf$VH() {
        return fuse_operations.write_buf$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*write_buf)(char*,struct fuse_bufvec*,off_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment write_buf$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.write_buf$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*write_buf)(char*,struct fuse_bufvec*,off_t,struct fuse_file_info*);
     * }
     */
    public static void write_buf$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.write_buf$VH.set(seg, x);
    }
    public static MemorySegment write_buf$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.write_buf$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void write_buf$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.write_buf$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static write_buf write_buf(MemorySegment segment, SegmentScope scope) {
        return write_buf.ofAddress(write_buf$get(segment), scope);
    }
    static final FunctionDescriptor read_buf$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle read_buf$MH = RuntimeHelper.downcallHandle(
        fuse_operations.read_buf$FUNC
    );
    /**
     * {@snippet :
 * int (*read_buf)(char*,struct fuse_bufvec**,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public interface read_buf {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2, long _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(read_buf fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(read_buf.class, fi, fuse_operations.read_buf$FUNC, scope);
        }
        static read_buf ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2, long __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)fuse_operations.read_buf$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle read_buf$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("read_buf"));
    public static VarHandle read_buf$VH() {
        return fuse_operations.read_buf$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*read_buf)(char*,struct fuse_bufvec**,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment read_buf$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.read_buf$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*read_buf)(char*,struct fuse_bufvec**,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public static void read_buf$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.read_buf$VH.set(seg, x);
    }
    public static MemorySegment read_buf$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.read_buf$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void read_buf$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.read_buf$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static read_buf read_buf(MemorySegment segment, SegmentScope scope) {
        return read_buf.ofAddress(read_buf$get(segment), scope);
    }
    static final FunctionDescriptor flock$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle flock$MH = RuntimeHelper.downcallHandle(
        fuse_operations.flock$FUNC
    );
    /**
     * {@snippet :
 * int (*flock)(char*,struct fuse_file_info*,int);
     * }
     */
    public interface flock {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, int _x2);
        static MemorySegment allocate(flock fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(flock.class, fi, fuse_operations.flock$FUNC, scope);
        }
        static flock ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, int __x2) -> {
                try {
                    return (int)fuse_operations.flock$MH.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle flock$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("flock"));
    public static VarHandle flock$VH() {
        return fuse_operations.flock$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*flock)(char*,struct fuse_file_info*,int);
     * }
     */
    public static MemorySegment flock$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.flock$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*flock)(char*,struct fuse_file_info*,int);
     * }
     */
    public static void flock$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.flock$VH.set(seg, x);
    }
    public static MemorySegment flock$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.flock$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void flock$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.flock$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static flock flock(MemorySegment segment, SegmentScope scope) {
        return flock.ofAddress(flock$get(segment), scope);
    }
    static final FunctionDescriptor fallocate$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle fallocate$MH = RuntimeHelper.downcallHandle(
        fuse_operations.fallocate$FUNC
    );
    /**
     * {@snippet :
 * int (*fallocate)(char*,int,off_t,off_t,struct fuse_file_info*);
     * }
     */
    public interface fallocate {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, long _x2, long _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(fallocate fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(fallocate.class, fi, fuse_operations.fallocate$FUNC, scope);
        }
        static fallocate ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, int __x1, long __x2, long __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)fuse_operations.fallocate$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle fallocate$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("fallocate"));
    public static VarHandle fallocate$VH() {
        return fuse_operations.fallocate$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*fallocate)(char*,int,off_t,off_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment fallocate$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.fallocate$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*fallocate)(char*,int,off_t,off_t,struct fuse_file_info*);
     * }
     */
    public static void fallocate$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.fallocate$VH.set(seg, x);
    }
    public static MemorySegment fallocate$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.fallocate$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void fallocate$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.fallocate$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static fallocate fallocate(MemorySegment segment, SegmentScope scope) {
        return fallocate.ofAddress(fallocate$get(segment), scope);
    }
    static final FunctionDescriptor copy_file_range$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle copy_file_range$MH = RuntimeHelper.downcallHandle(
        fuse_operations.copy_file_range$FUNC
    );
    /**
     * {@snippet :
 * ssize_t (*copy_file_range)(char*,struct fuse_file_info*,off_t,char*,struct fuse_file_info*,off_t,size_t,int);
     * }
     */
    public interface copy_file_range {

        long apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2, java.lang.foreign.MemorySegment _x3, java.lang.foreign.MemorySegment _x4, long _x5, long _x6, int _x7);
        static MemorySegment allocate(copy_file_range fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(copy_file_range.class, fi, fuse_operations.copy_file_range$FUNC, scope);
        }
        static copy_file_range ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2, java.lang.foreign.MemorySegment __x3, java.lang.foreign.MemorySegment __x4, long __x5, long __x6, int __x7) -> {
                try {
                    return (long)fuse_operations.copy_file_range$MH.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4, __x5, __x6, __x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle copy_file_range$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("copy_file_range"));
    public static VarHandle copy_file_range$VH() {
        return fuse_operations.copy_file_range$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * ssize_t (*copy_file_range)(char*,struct fuse_file_info*,off_t,char*,struct fuse_file_info*,off_t,size_t,int);
     * }
     */
    public static MemorySegment copy_file_range$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.copy_file_range$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * ssize_t (*copy_file_range)(char*,struct fuse_file_info*,off_t,char*,struct fuse_file_info*,off_t,size_t,int);
     * }
     */
    public static void copy_file_range$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.copy_file_range$VH.set(seg, x);
    }
    public static MemorySegment copy_file_range$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.copy_file_range$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void copy_file_range$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.copy_file_range$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static copy_file_range copy_file_range(MemorySegment segment, SegmentScope scope) {
        return copy_file_range.ofAddress(copy_file_range$get(segment), scope);
    }
    static final FunctionDescriptor lseek$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle lseek$MH = RuntimeHelper.downcallHandle(
        fuse_operations.lseek$FUNC
    );
    /**
     * {@snippet :
 * off_t (*lseek)(char*,off_t,int,struct fuse_file_info*);
     * }
     */
    public interface lseek {

        long apply(java.lang.foreign.MemorySegment _x0, long _x1, int _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(lseek fi, SegmentScope scope) {
            return RuntimeHelper.upcallStub(lseek.class, fi, fuse_operations.lseek$FUNC, scope);
        }
        static lseek ofAddress(MemorySegment addr, SegmentScope scope) {
            MemorySegment symbol = MemorySegment.ofAddress(addr.address(), 0, scope);
            return (java.lang.foreign.MemorySegment __x0, long __x1, int __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    return (long)fuse_operations.lseek$MH.invokeExact(symbol, __x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle lseek$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("lseek"));
    public static VarHandle lseek$VH() {
        return fuse_operations.lseek$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * off_t (*lseek)(char*,off_t,int,struct fuse_file_info*);
     * }
     */
    public static MemorySegment lseek$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)fuse_operations.lseek$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * off_t (*lseek)(char*,off_t,int,struct fuse_file_info*);
     * }
     */
    public static void lseek$set(MemorySegment seg, MemorySegment x) {
        fuse_operations.lseek$VH.set(seg, x);
    }
    public static MemorySegment lseek$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)fuse_operations.lseek$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void lseek$set(MemorySegment seg, long index, MemorySegment x) {
        fuse_operations.lseek$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static lseek lseek(MemorySegment segment, SegmentScope scope) {
        return lseek.ofAddress(lseek$get(segment), scope);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemorySegment addr, SegmentScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


