// Generated by jextract

package org.cryptomator.jfuse.linux.amd64.extr.fuse3;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct fuse_operations {
 *     int (*getattr)(const char *, struct stat *, struct fuse_file_info *);
 *     int (*readlink)(const char *, char *, size_t);
 *     int (*mknod)(const char *, mode_t, dev_t);
 *     int (*mkdir)(const char *, mode_t);
 *     int (*unlink)(const char *);
 *     int (*rmdir)(const char *);
 *     int (*symlink)(const char *, const char *);
 *     int (*rename)(const char *, const char *, unsigned int);
 *     int (*link)(const char *, const char *);
 *     int (*chmod)(const char *, mode_t, struct fuse_file_info *);
 *     int (*chown)(const char *, uid_t, gid_t, struct fuse_file_info *);
 *     int (*truncate)(const char *, off_t, struct fuse_file_info *);
 *     int (*open)(const char *, struct fuse_file_info *);
 *     int (*read)(const char *, char *, size_t, off_t, struct fuse_file_info *);
 *     int (*write)(const char *, const char *, size_t, off_t, struct fuse_file_info *);
 *     int (*statfs)(const char *, struct statvfs *);
 *     int (*flush)(const char *, struct fuse_file_info *);
 *     int (*release)(const char *, struct fuse_file_info *);
 *     int (*fsync)(const char *, int, struct fuse_file_info *);
 *     int (*setxattr)(const char *, const char *, const char *, size_t, int);
 *     int (*getxattr)(const char *, const char *, char *, size_t);
 *     int (*listxattr)(const char *, char *, size_t);
 *     int (*removexattr)(const char *, const char *);
 *     int (*opendir)(const char *, struct fuse_file_info *);
 *     int (*readdir)(const char *, void *, fuse_fill_dir_t, off_t, struct fuse_file_info *, enum fuse_readdir_flags);
 *     int (*releasedir)(const char *, struct fuse_file_info *);
 *     int (*fsyncdir)(const char *, int, struct fuse_file_info *);
 *     void *(*init)(struct fuse_conn_info *, struct fuse_config *);
 *     void (*destroy)(void *);
 *     int (*access)(const char *, int);
 *     int (*create)(const char *, mode_t, struct fuse_file_info *);
 *     int (*lock)(const char *, struct fuse_file_info *, int, struct flock *);
 *     int (*utimens)(const char *, const struct timespec *, struct fuse_file_info *);
 *     int (*bmap)(const char *, size_t, uint64_t *);
 *     int (*ioctl)(const char *, unsigned int, void *, struct fuse_file_info *, unsigned int, void *);
 *     int (*poll)(const char *, struct fuse_file_info *, struct fuse_pollhandle *, unsigned int *);
 *     int (*write_buf)(const char *, struct fuse_bufvec *, off_t, struct fuse_file_info *);
 *     int (*read_buf)(const char *, struct fuse_bufvec **, size_t, off_t, struct fuse_file_info *);
 *     int (*flock)(const char *, struct fuse_file_info *, int);
 *     int (*fallocate)(const char *, int, off_t, off_t, struct fuse_file_info *);
 *     ssize_t (*copy_file_range)(const char *, struct fuse_file_info *, off_t, const char *, struct fuse_file_info *, off_t, size_t, int);
 *     off_t (*lseek)(const char *, off_t, int, struct fuse_file_info *);
 * }
 * }
 */
public class fuse_operations {

    fuse_operations() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        fuse_h.C_POINTER.withName("getattr"),
        fuse_h.C_POINTER.withName("readlink"),
        fuse_h.C_POINTER.withName("mknod"),
        fuse_h.C_POINTER.withName("mkdir"),
        fuse_h.C_POINTER.withName("unlink"),
        fuse_h.C_POINTER.withName("rmdir"),
        fuse_h.C_POINTER.withName("symlink"),
        fuse_h.C_POINTER.withName("rename"),
        fuse_h.C_POINTER.withName("link"),
        fuse_h.C_POINTER.withName("chmod"),
        fuse_h.C_POINTER.withName("chown"),
        fuse_h.C_POINTER.withName("truncate"),
        fuse_h.C_POINTER.withName("open"),
        fuse_h.C_POINTER.withName("read"),
        fuse_h.C_POINTER.withName("write"),
        fuse_h.C_POINTER.withName("statfs"),
        fuse_h.C_POINTER.withName("flush"),
        fuse_h.C_POINTER.withName("release"),
        fuse_h.C_POINTER.withName("fsync"),
        fuse_h.C_POINTER.withName("setxattr"),
        fuse_h.C_POINTER.withName("getxattr"),
        fuse_h.C_POINTER.withName("listxattr"),
        fuse_h.C_POINTER.withName("removexattr"),
        fuse_h.C_POINTER.withName("opendir"),
        fuse_h.C_POINTER.withName("readdir"),
        fuse_h.C_POINTER.withName("releasedir"),
        fuse_h.C_POINTER.withName("fsyncdir"),
        fuse_h.C_POINTER.withName("init"),
        fuse_h.C_POINTER.withName("destroy"),
        fuse_h.C_POINTER.withName("access"),
        fuse_h.C_POINTER.withName("create"),
        fuse_h.C_POINTER.withName("lock"),
        fuse_h.C_POINTER.withName("utimens"),
        fuse_h.C_POINTER.withName("bmap"),
        fuse_h.C_POINTER.withName("ioctl"),
        fuse_h.C_POINTER.withName("poll"),
        fuse_h.C_POINTER.withName("write_buf"),
        fuse_h.C_POINTER.withName("read_buf"),
        fuse_h.C_POINTER.withName("flock"),
        fuse_h.C_POINTER.withName("fallocate"),
        fuse_h.C_POINTER.withName("copy_file_range"),
        fuse_h.C_POINTER.withName("lseek")
    ).withName("fuse_operations");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * int (*getattr)(const char *, struct stat *, struct fuse_file_info *)
     * }
     */
    public static class getattr {

        getattr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(getattr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(getattr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout getattr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("getattr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*getattr)(const char *, struct stat *, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout getattr$layout() {
        return getattr$LAYOUT;
    }

    private static final long getattr$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*getattr)(const char *, struct stat *, struct fuse_file_info *)
     * }
     */
    public static final long getattr$offset() {
        return getattr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*getattr)(const char *, struct stat *, struct fuse_file_info *)
     * }
     */
    public static MemorySegment getattr(MemorySegment struct) {
        return struct.get(getattr$LAYOUT, getattr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*getattr)(const char *, struct stat *, struct fuse_file_info *)
     * }
     */
    public static void getattr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(getattr$LAYOUT, getattr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*readlink)(const char *, char *, size_t)
     * }
     */
    public static class readlink {

        readlink() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(readlink.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(readlink.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout readlink$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("readlink"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*readlink)(const char *, char *, size_t)
     * }
     */
    public static final AddressLayout readlink$layout() {
        return readlink$LAYOUT;
    }

    private static final long readlink$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*readlink)(const char *, char *, size_t)
     * }
     */
    public static final long readlink$offset() {
        return readlink$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*readlink)(const char *, char *, size_t)
     * }
     */
    public static MemorySegment readlink(MemorySegment struct) {
        return struct.get(readlink$LAYOUT, readlink$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*readlink)(const char *, char *, size_t)
     * }
     */
    public static void readlink(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(readlink$LAYOUT, readlink$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*mknod)(const char *, mode_t, dev_t)
     * }
     */
    public static class mknod {

        mknod() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_INT,
            fuse_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(mknod.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(mknod.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, long _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mknod$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mknod"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*mknod)(const char *, mode_t, dev_t)
     * }
     */
    public static final AddressLayout mknod$layout() {
        return mknod$LAYOUT;
    }

    private static final long mknod$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*mknod)(const char *, mode_t, dev_t)
     * }
     */
    public static final long mknod$offset() {
        return mknod$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*mknod)(const char *, mode_t, dev_t)
     * }
     */
    public static MemorySegment mknod(MemorySegment struct) {
        return struct.get(mknod$LAYOUT, mknod$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*mknod)(const char *, mode_t, dev_t)
     * }
     */
    public static void mknod(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mknod$LAYOUT, mknod$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*mkdir)(const char *, mode_t)
     * }
     */
    public static class mkdir {

        mkdir() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(mkdir.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(mkdir.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout mkdir$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("mkdir"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*mkdir)(const char *, mode_t)
     * }
     */
    public static final AddressLayout mkdir$layout() {
        return mkdir$LAYOUT;
    }

    private static final long mkdir$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*mkdir)(const char *, mode_t)
     * }
     */
    public static final long mkdir$offset() {
        return mkdir$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*mkdir)(const char *, mode_t)
     * }
     */
    public static MemorySegment mkdir(MemorySegment struct) {
        return struct.get(mkdir$LAYOUT, mkdir$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*mkdir)(const char *, mode_t)
     * }
     */
    public static void mkdir(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(mkdir$LAYOUT, mkdir$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*unlink)(const char *)
     * }
     */
    public static class unlink {

        unlink() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(unlink.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(unlink.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout unlink$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("unlink"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*unlink)(const char *)
     * }
     */
    public static final AddressLayout unlink$layout() {
        return unlink$LAYOUT;
    }

    private static final long unlink$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*unlink)(const char *)
     * }
     */
    public static final long unlink$offset() {
        return unlink$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*unlink)(const char *)
     * }
     */
    public static MemorySegment unlink(MemorySegment struct) {
        return struct.get(unlink$LAYOUT, unlink$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*unlink)(const char *)
     * }
     */
    public static void unlink(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(unlink$LAYOUT, unlink$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*rmdir)(const char *)
     * }
     */
    public static class rmdir {

        rmdir() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(rmdir.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(rmdir.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout rmdir$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("rmdir"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*rmdir)(const char *)
     * }
     */
    public static final AddressLayout rmdir$layout() {
        return rmdir$LAYOUT;
    }

    private static final long rmdir$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*rmdir)(const char *)
     * }
     */
    public static final long rmdir$offset() {
        return rmdir$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*rmdir)(const char *)
     * }
     */
    public static MemorySegment rmdir(MemorySegment struct) {
        return struct.get(rmdir$LAYOUT, rmdir$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*rmdir)(const char *)
     * }
     */
    public static void rmdir(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(rmdir$LAYOUT, rmdir$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*symlink)(const char *, const char *)
     * }
     */
    public static class symlink {

        symlink() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(symlink.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(symlink.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout symlink$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("symlink"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*symlink)(const char *, const char *)
     * }
     */
    public static final AddressLayout symlink$layout() {
        return symlink$LAYOUT;
    }

    private static final long symlink$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*symlink)(const char *, const char *)
     * }
     */
    public static final long symlink$offset() {
        return symlink$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*symlink)(const char *, const char *)
     * }
     */
    public static MemorySegment symlink(MemorySegment struct) {
        return struct.get(symlink$LAYOUT, symlink$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*symlink)(const char *, const char *)
     * }
     */
    public static void symlink(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(symlink$LAYOUT, symlink$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*rename)(const char *, const char *, unsigned int)
     * }
     */
    public static class rename {

        rename() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(rename.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(rename.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout rename$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("rename"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*rename)(const char *, const char *, unsigned int)
     * }
     */
    public static final AddressLayout rename$layout() {
        return rename$LAYOUT;
    }

    private static final long rename$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*rename)(const char *, const char *, unsigned int)
     * }
     */
    public static final long rename$offset() {
        return rename$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*rename)(const char *, const char *, unsigned int)
     * }
     */
    public static MemorySegment rename(MemorySegment struct) {
        return struct.get(rename$LAYOUT, rename$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*rename)(const char *, const char *, unsigned int)
     * }
     */
    public static void rename(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(rename$LAYOUT, rename$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*link)(const char *, const char *)
     * }
     */
    public static class link {

        link() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(link.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(link.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout link$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("link"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*link)(const char *, const char *)
     * }
     */
    public static final AddressLayout link$layout() {
        return link$LAYOUT;
    }

    private static final long link$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*link)(const char *, const char *)
     * }
     */
    public static final long link$offset() {
        return link$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*link)(const char *, const char *)
     * }
     */
    public static MemorySegment link(MemorySegment struct) {
        return struct.get(link$LAYOUT, link$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*link)(const char *, const char *)
     * }
     */
    public static void link(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(link$LAYOUT, link$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*chmod)(const char *, mode_t, struct fuse_file_info *)
     * }
     */
    public static class chmod {

        chmod() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_INT,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(chmod.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(chmod.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout chmod$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("chmod"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*chmod)(const char *, mode_t, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout chmod$layout() {
        return chmod$LAYOUT;
    }

    private static final long chmod$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*chmod)(const char *, mode_t, struct fuse_file_info *)
     * }
     */
    public static final long chmod$offset() {
        return chmod$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*chmod)(const char *, mode_t, struct fuse_file_info *)
     * }
     */
    public static MemorySegment chmod(MemorySegment struct) {
        return struct.get(chmod$LAYOUT, chmod$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*chmod)(const char *, mode_t, struct fuse_file_info *)
     * }
     */
    public static void chmod(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(chmod$LAYOUT, chmod$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*chown)(const char *, uid_t, gid_t, struct fuse_file_info *)
     * }
     */
    public static class chown {

        chown() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_INT,
            fuse_h.C_INT,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(chown.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(chown.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout chown$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("chown"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*chown)(const char *, uid_t, gid_t, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout chown$layout() {
        return chown$LAYOUT;
    }

    private static final long chown$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*chown)(const char *, uid_t, gid_t, struct fuse_file_info *)
     * }
     */
    public static final long chown$offset() {
        return chown$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*chown)(const char *, uid_t, gid_t, struct fuse_file_info *)
     * }
     */
    public static MemorySegment chown(MemorySegment struct) {
        return struct.get(chown$LAYOUT, chown$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*chown)(const char *, uid_t, gid_t, struct fuse_file_info *)
     * }
     */
    public static void chown(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(chown$LAYOUT, chown$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*truncate)(const char *, off_t, struct fuse_file_info *)
     * }
     */
    public static class truncate {

        truncate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_LONG,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(truncate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(truncate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout truncate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("truncate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*truncate)(const char *, off_t, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout truncate$layout() {
        return truncate$LAYOUT;
    }

    private static final long truncate$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*truncate)(const char *, off_t, struct fuse_file_info *)
     * }
     */
    public static final long truncate$offset() {
        return truncate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*truncate)(const char *, off_t, struct fuse_file_info *)
     * }
     */
    public static MemorySegment truncate(MemorySegment struct) {
        return struct.get(truncate$LAYOUT, truncate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*truncate)(const char *, off_t, struct fuse_file_info *)
     * }
     */
    public static void truncate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(truncate$LAYOUT, truncate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*open)(const char *, struct fuse_file_info *)
     * }
     */
    public static class open {

        open() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(open.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(open.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout open$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("open"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*open)(const char *, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout open$layout() {
        return open$LAYOUT;
    }

    private static final long open$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*open)(const char *, struct fuse_file_info *)
     * }
     */
    public static final long open$offset() {
        return open$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*open)(const char *, struct fuse_file_info *)
     * }
     */
    public static MemorySegment open(MemorySegment struct) {
        return struct.get(open$LAYOUT, open$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*open)(const char *, struct fuse_file_info *)
     * }
     */
    public static void open(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(open$LAYOUT, open$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*read)(const char *, char *, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static class read {

        read() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_LONG,
            fuse_h.C_LONG,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(read.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*read)(const char *, char *, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout read$layout() {
        return read$LAYOUT;
    }

    private static final long read$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*read)(const char *, char *, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static final long read$offset() {
        return read$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*read)(const char *, char *, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static MemorySegment read(MemorySegment struct) {
        return struct.get(read$LAYOUT, read$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*read)(const char *, char *, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static void read(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read$LAYOUT, read$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*write)(const char *, const char *, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static class write {

        write() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_LONG,
            fuse_h.C_LONG,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(write.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(write.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout write$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("write"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*write)(const char *, const char *, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout write$layout() {
        return write$LAYOUT;
    }

    private static final long write$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*write)(const char *, const char *, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static final long write$offset() {
        return write$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*write)(const char *, const char *, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static MemorySegment write(MemorySegment struct) {
        return struct.get(write$LAYOUT, write$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*write)(const char *, const char *, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static void write(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(write$LAYOUT, write$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*statfs)(const char *, struct statvfs *)
     * }
     */
    public static class statfs {

        statfs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(statfs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(statfs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout statfs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("statfs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*statfs)(const char *, struct statvfs *)
     * }
     */
    public static final AddressLayout statfs$layout() {
        return statfs$LAYOUT;
    }

    private static final long statfs$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*statfs)(const char *, struct statvfs *)
     * }
     */
    public static final long statfs$offset() {
        return statfs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*statfs)(const char *, struct statvfs *)
     * }
     */
    public static MemorySegment statfs(MemorySegment struct) {
        return struct.get(statfs$LAYOUT, statfs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*statfs)(const char *, struct statvfs *)
     * }
     */
    public static void statfs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(statfs$LAYOUT, statfs$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*flush)(const char *, struct fuse_file_info *)
     * }
     */
    public static class flush {

        flush() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(flush.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(flush.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout flush$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("flush"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*flush)(const char *, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout flush$layout() {
        return flush$LAYOUT;
    }

    private static final long flush$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*flush)(const char *, struct fuse_file_info *)
     * }
     */
    public static final long flush$offset() {
        return flush$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*flush)(const char *, struct fuse_file_info *)
     * }
     */
    public static MemorySegment flush(MemorySegment struct) {
        return struct.get(flush$LAYOUT, flush$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*flush)(const char *, struct fuse_file_info *)
     * }
     */
    public static void flush(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(flush$LAYOUT, flush$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*release)(const char *, struct fuse_file_info *)
     * }
     */
    public static class release {

        release() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(release.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(release.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout release$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("release"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*release)(const char *, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout release$layout() {
        return release$LAYOUT;
    }

    private static final long release$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*release)(const char *, struct fuse_file_info *)
     * }
     */
    public static final long release$offset() {
        return release$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*release)(const char *, struct fuse_file_info *)
     * }
     */
    public static MemorySegment release(MemorySegment struct) {
        return struct.get(release$LAYOUT, release$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*release)(const char *, struct fuse_file_info *)
     * }
     */
    public static void release(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(release$LAYOUT, release$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*fsync)(const char *, int, struct fuse_file_info *)
     * }
     */
    public static class fsync {

        fsync() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_INT,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(fsync.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(fsync.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout fsync$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fsync"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*fsync)(const char *, int, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout fsync$layout() {
        return fsync$LAYOUT;
    }

    private static final long fsync$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*fsync)(const char *, int, struct fuse_file_info *)
     * }
     */
    public static final long fsync$offset() {
        return fsync$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*fsync)(const char *, int, struct fuse_file_info *)
     * }
     */
    public static MemorySegment fsync(MemorySegment struct) {
        return struct.get(fsync$LAYOUT, fsync$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*fsync)(const char *, int, struct fuse_file_info *)
     * }
     */
    public static void fsync(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fsync$LAYOUT, fsync$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*setxattr)(const char *, const char *, const char *, size_t, int)
     * }
     */
    public static class setxattr {

        setxattr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, int _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_LONG,
            fuse_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(setxattr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(setxattr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, int _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout setxattr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("setxattr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*setxattr)(const char *, const char *, const char *, size_t, int)
     * }
     */
    public static final AddressLayout setxattr$layout() {
        return setxattr$LAYOUT;
    }

    private static final long setxattr$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*setxattr)(const char *, const char *, const char *, size_t, int)
     * }
     */
    public static final long setxattr$offset() {
        return setxattr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*setxattr)(const char *, const char *, const char *, size_t, int)
     * }
     */
    public static MemorySegment setxattr(MemorySegment struct) {
        return struct.get(setxattr$LAYOUT, setxattr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*setxattr)(const char *, const char *, const char *, size_t, int)
     * }
     */
    public static void setxattr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(setxattr$LAYOUT, setxattr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*getxattr)(const char *, const char *, char *, size_t)
     * }
     */
    public static class getxattr {

        getxattr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(getxattr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(getxattr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout getxattr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("getxattr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*getxattr)(const char *, const char *, char *, size_t)
     * }
     */
    public static final AddressLayout getxattr$layout() {
        return getxattr$LAYOUT;
    }

    private static final long getxattr$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*getxattr)(const char *, const char *, char *, size_t)
     * }
     */
    public static final long getxattr$offset() {
        return getxattr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*getxattr)(const char *, const char *, char *, size_t)
     * }
     */
    public static MemorySegment getxattr(MemorySegment struct) {
        return struct.get(getxattr$LAYOUT, getxattr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*getxattr)(const char *, const char *, char *, size_t)
     * }
     */
    public static void getxattr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(getxattr$LAYOUT, getxattr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*listxattr)(const char *, char *, size_t)
     * }
     */
    public static class listxattr {

        listxattr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(listxattr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(listxattr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout listxattr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("listxattr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*listxattr)(const char *, char *, size_t)
     * }
     */
    public static final AddressLayout listxattr$layout() {
        return listxattr$LAYOUT;
    }

    private static final long listxattr$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*listxattr)(const char *, char *, size_t)
     * }
     */
    public static final long listxattr$offset() {
        return listxattr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*listxattr)(const char *, char *, size_t)
     * }
     */
    public static MemorySegment listxattr(MemorySegment struct) {
        return struct.get(listxattr$LAYOUT, listxattr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*listxattr)(const char *, char *, size_t)
     * }
     */
    public static void listxattr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(listxattr$LAYOUT, listxattr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*removexattr)(const char *, const char *)
     * }
     */
    public static class removexattr {

        removexattr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(removexattr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(removexattr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout removexattr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("removexattr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*removexattr)(const char *, const char *)
     * }
     */
    public static final AddressLayout removexattr$layout() {
        return removexattr$LAYOUT;
    }

    private static final long removexattr$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*removexattr)(const char *, const char *)
     * }
     */
    public static final long removexattr$offset() {
        return removexattr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*removexattr)(const char *, const char *)
     * }
     */
    public static MemorySegment removexattr(MemorySegment struct) {
        return struct.get(removexattr$LAYOUT, removexattr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*removexattr)(const char *, const char *)
     * }
     */
    public static void removexattr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(removexattr$LAYOUT, removexattr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*opendir)(const char *, struct fuse_file_info *)
     * }
     */
    public static class opendir {

        opendir() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(opendir.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(opendir.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout opendir$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("opendir"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*opendir)(const char *, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout opendir$layout() {
        return opendir$LAYOUT;
    }

    private static final long opendir$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*opendir)(const char *, struct fuse_file_info *)
     * }
     */
    public static final long opendir$offset() {
        return opendir$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*opendir)(const char *, struct fuse_file_info *)
     * }
     */
    public static MemorySegment opendir(MemorySegment struct) {
        return struct.get(opendir$LAYOUT, opendir$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*opendir)(const char *, struct fuse_file_info *)
     * }
     */
    public static void opendir(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(opendir$LAYOUT, opendir$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*readdir)(const char *, void *, fuse_fill_dir_t, off_t, struct fuse_file_info *, enum fuse_readdir_flags)
     * }
     */
    public static class readdir {

        readdir() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, int _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_LONG,
            fuse_h.C_POINTER,
            fuse_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(readdir.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(readdir.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, int _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout readdir$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("readdir"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*readdir)(const char *, void *, fuse_fill_dir_t, off_t, struct fuse_file_info *, enum fuse_readdir_flags)
     * }
     */
    public static final AddressLayout readdir$layout() {
        return readdir$LAYOUT;
    }

    private static final long readdir$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*readdir)(const char *, void *, fuse_fill_dir_t, off_t, struct fuse_file_info *, enum fuse_readdir_flags)
     * }
     */
    public static final long readdir$offset() {
        return readdir$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*readdir)(const char *, void *, fuse_fill_dir_t, off_t, struct fuse_file_info *, enum fuse_readdir_flags)
     * }
     */
    public static MemorySegment readdir(MemorySegment struct) {
        return struct.get(readdir$LAYOUT, readdir$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*readdir)(const char *, void *, fuse_fill_dir_t, off_t, struct fuse_file_info *, enum fuse_readdir_flags)
     * }
     */
    public static void readdir(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(readdir$LAYOUT, readdir$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*releasedir)(const char *, struct fuse_file_info *)
     * }
     */
    public static class releasedir {

        releasedir() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(releasedir.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(releasedir.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout releasedir$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("releasedir"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*releasedir)(const char *, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout releasedir$layout() {
        return releasedir$LAYOUT;
    }

    private static final long releasedir$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*releasedir)(const char *, struct fuse_file_info *)
     * }
     */
    public static final long releasedir$offset() {
        return releasedir$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*releasedir)(const char *, struct fuse_file_info *)
     * }
     */
    public static MemorySegment releasedir(MemorySegment struct) {
        return struct.get(releasedir$LAYOUT, releasedir$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*releasedir)(const char *, struct fuse_file_info *)
     * }
     */
    public static void releasedir(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(releasedir$LAYOUT, releasedir$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*fsyncdir)(const char *, int, struct fuse_file_info *)
     * }
     */
    public static class fsyncdir {

        fsyncdir() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_INT,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(fsyncdir.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(fsyncdir.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout fsyncdir$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fsyncdir"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*fsyncdir)(const char *, int, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout fsyncdir$layout() {
        return fsyncdir$LAYOUT;
    }

    private static final long fsyncdir$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*fsyncdir)(const char *, int, struct fuse_file_info *)
     * }
     */
    public static final long fsyncdir$offset() {
        return fsyncdir$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*fsyncdir)(const char *, int, struct fuse_file_info *)
     * }
     */
    public static MemorySegment fsyncdir(MemorySegment struct) {
        return struct.get(fsyncdir$LAYOUT, fsyncdir$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*fsyncdir)(const char *, int, struct fuse_file_info *)
     * }
     */
    public static void fsyncdir(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fsyncdir$LAYOUT, fsyncdir$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*init)(struct fuse_conn_info *, struct fuse_config *)
     * }
     */
    public static class init {

        init() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(init.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(init.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout init$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("init"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*init)(struct fuse_conn_info *, struct fuse_config *)
     * }
     */
    public static final AddressLayout init$layout() {
        return init$LAYOUT;
    }

    private static final long init$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*init)(struct fuse_conn_info *, struct fuse_config *)
     * }
     */
    public static final long init$offset() {
        return init$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*init)(struct fuse_conn_info *, struct fuse_config *)
     * }
     */
    public static MemorySegment init(MemorySegment struct) {
        return struct.get(init$LAYOUT, init$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*init)(struct fuse_conn_info *, struct fuse_config *)
     * }
     */
    public static void init(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(init$LAYOUT, init$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*destroy)(void *)
     * }
     */
    public static class destroy {

        destroy() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(destroy.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(destroy.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout destroy$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("destroy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*destroy)(void *)
     * }
     */
    public static final AddressLayout destroy$layout() {
        return destroy$LAYOUT;
    }

    private static final long destroy$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*destroy)(void *)
     * }
     */
    public static final long destroy$offset() {
        return destroy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*destroy)(void *)
     * }
     */
    public static MemorySegment destroy(MemorySegment struct) {
        return struct.get(destroy$LAYOUT, destroy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*destroy)(void *)
     * }
     */
    public static void destroy(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(destroy$LAYOUT, destroy$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*access)(const char *, int)
     * }
     */
    public static class access {

        access() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(access.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(access.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout access$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("access"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*access)(const char *, int)
     * }
     */
    public static final AddressLayout access$layout() {
        return access$LAYOUT;
    }

    private static final long access$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*access)(const char *, int)
     * }
     */
    public static final long access$offset() {
        return access$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*access)(const char *, int)
     * }
     */
    public static MemorySegment access(MemorySegment struct) {
        return struct.get(access$LAYOUT, access$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*access)(const char *, int)
     * }
     */
    public static void access(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(access$LAYOUT, access$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*create)(const char *, mode_t, struct fuse_file_info *)
     * }
     */
    public static class create {

        create() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_INT,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(create.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*create)(const char *, mode_t, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout create$layout() {
        return create$LAYOUT;
    }

    private static final long create$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*create)(const char *, mode_t, struct fuse_file_info *)
     * }
     */
    public static final long create$offset() {
        return create$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*create)(const char *, mode_t, struct fuse_file_info *)
     * }
     */
    public static MemorySegment create(MemorySegment struct) {
        return struct.get(create$LAYOUT, create$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*create)(const char *, mode_t, struct fuse_file_info *)
     * }
     */
    public static void create(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create$LAYOUT, create$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*lock)(const char *, struct fuse_file_info *, int, struct flock *)
     * }
     */
    public static class lock {

        lock() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_INT,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(lock.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(lock.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout lock$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("lock"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*lock)(const char *, struct fuse_file_info *, int, struct flock *)
     * }
     */
    public static final AddressLayout lock$layout() {
        return lock$LAYOUT;
    }

    private static final long lock$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*lock)(const char *, struct fuse_file_info *, int, struct flock *)
     * }
     */
    public static final long lock$offset() {
        return lock$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*lock)(const char *, struct fuse_file_info *, int, struct flock *)
     * }
     */
    public static MemorySegment lock(MemorySegment struct) {
        return struct.get(lock$LAYOUT, lock$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*lock)(const char *, struct fuse_file_info *, int, struct flock *)
     * }
     */
    public static void lock(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(lock$LAYOUT, lock$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*utimens)(const char *, const struct timespec *, struct fuse_file_info *)
     * }
     */
    public static class utimens {

        utimens() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(utimens.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(utimens.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout utimens$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("utimens"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*utimens)(const char *, const struct timespec *, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout utimens$layout() {
        return utimens$LAYOUT;
    }

    private static final long utimens$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*utimens)(const char *, const struct timespec *, struct fuse_file_info *)
     * }
     */
    public static final long utimens$offset() {
        return utimens$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*utimens)(const char *, const struct timespec *, struct fuse_file_info *)
     * }
     */
    public static MemorySegment utimens(MemorySegment struct) {
        return struct.get(utimens$LAYOUT, utimens$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*utimens)(const char *, const struct timespec *, struct fuse_file_info *)
     * }
     */
    public static void utimens(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(utimens$LAYOUT, utimens$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*bmap)(const char *, size_t, uint64_t *)
     * }
     */
    public static class bmap {

        bmap() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_LONG,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(bmap.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(bmap.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout bmap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("bmap"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*bmap)(const char *, size_t, uint64_t *)
     * }
     */
    public static final AddressLayout bmap$layout() {
        return bmap$LAYOUT;
    }

    private static final long bmap$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*bmap)(const char *, size_t, uint64_t *)
     * }
     */
    public static final long bmap$offset() {
        return bmap$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*bmap)(const char *, size_t, uint64_t *)
     * }
     */
    public static MemorySegment bmap(MemorySegment struct) {
        return struct.get(bmap$LAYOUT, bmap$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*bmap)(const char *, size_t, uint64_t *)
     * }
     */
    public static void bmap(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(bmap$LAYOUT, bmap$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*ioctl)(const char *, unsigned int, void *, struct fuse_file_info *, unsigned int, void *)
     * }
     */
    public static class ioctl {

        ioctl() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_INT,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(ioctl.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ioctl.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, MemorySegment _x5) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ioctl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ioctl"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*ioctl)(const char *, unsigned int, void *, struct fuse_file_info *, unsigned int, void *)
     * }
     */
    public static final AddressLayout ioctl$layout() {
        return ioctl$LAYOUT;
    }

    private static final long ioctl$OFFSET = 272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*ioctl)(const char *, unsigned int, void *, struct fuse_file_info *, unsigned int, void *)
     * }
     */
    public static final long ioctl$offset() {
        return ioctl$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*ioctl)(const char *, unsigned int, void *, struct fuse_file_info *, unsigned int, void *)
     * }
     */
    public static MemorySegment ioctl(MemorySegment struct) {
        return struct.get(ioctl$LAYOUT, ioctl$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*ioctl)(const char *, unsigned int, void *, struct fuse_file_info *, unsigned int, void *)
     * }
     */
    public static void ioctl(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ioctl$LAYOUT, ioctl$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*poll)(const char *, struct fuse_file_info *, struct fuse_pollhandle *, unsigned int *)
     * }
     */
    public static class poll {

        poll() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(poll.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(poll.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout poll$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("poll"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*poll)(const char *, struct fuse_file_info *, struct fuse_pollhandle *, unsigned int *)
     * }
     */
    public static final AddressLayout poll$layout() {
        return poll$LAYOUT;
    }

    private static final long poll$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*poll)(const char *, struct fuse_file_info *, struct fuse_pollhandle *, unsigned int *)
     * }
     */
    public static final long poll$offset() {
        return poll$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*poll)(const char *, struct fuse_file_info *, struct fuse_pollhandle *, unsigned int *)
     * }
     */
    public static MemorySegment poll(MemorySegment struct) {
        return struct.get(poll$LAYOUT, poll$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*poll)(const char *, struct fuse_file_info *, struct fuse_pollhandle *, unsigned int *)
     * }
     */
    public static void poll(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(poll$LAYOUT, poll$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*write_buf)(const char *, struct fuse_bufvec *, off_t, struct fuse_file_info *)
     * }
     */
    public static class write_buf {

        write_buf() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_LONG,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(write_buf.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(write_buf.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout write_buf$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("write_buf"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*write_buf)(const char *, struct fuse_bufvec *, off_t, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout write_buf$layout() {
        return write_buf$LAYOUT;
    }

    private static final long write_buf$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*write_buf)(const char *, struct fuse_bufvec *, off_t, struct fuse_file_info *)
     * }
     */
    public static final long write_buf$offset() {
        return write_buf$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*write_buf)(const char *, struct fuse_bufvec *, off_t, struct fuse_file_info *)
     * }
     */
    public static MemorySegment write_buf(MemorySegment struct) {
        return struct.get(write_buf$LAYOUT, write_buf$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*write_buf)(const char *, struct fuse_bufvec *, off_t, struct fuse_file_info *)
     * }
     */
    public static void write_buf(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(write_buf$LAYOUT, write_buf$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*read_buf)(const char *, struct fuse_bufvec **, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static class read_buf {

        read_buf() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_LONG,
            fuse_h.C_LONG,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(read_buf.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_buf.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_buf$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_buf"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*read_buf)(const char *, struct fuse_bufvec **, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout read_buf$layout() {
        return read_buf$LAYOUT;
    }

    private static final long read_buf$OFFSET = 296;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*read_buf)(const char *, struct fuse_bufvec **, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static final long read_buf$offset() {
        return read_buf$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*read_buf)(const char *, struct fuse_bufvec **, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static MemorySegment read_buf(MemorySegment struct) {
        return struct.get(read_buf$LAYOUT, read_buf$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*read_buf)(const char *, struct fuse_bufvec **, size_t, off_t, struct fuse_file_info *)
     * }
     */
    public static void read_buf(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_buf$LAYOUT, read_buf$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*flock)(const char *, struct fuse_file_info *, int)
     * }
     */
    public static class flock {

        flock() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(flock.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(flock.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout flock$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("flock"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*flock)(const char *, struct fuse_file_info *, int)
     * }
     */
    public static final AddressLayout flock$layout() {
        return flock$LAYOUT;
    }

    private static final long flock$OFFSET = 304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*flock)(const char *, struct fuse_file_info *, int)
     * }
     */
    public static final long flock$offset() {
        return flock$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*flock)(const char *, struct fuse_file_info *, int)
     * }
     */
    public static MemorySegment flock(MemorySegment struct) {
        return struct.get(flock$LAYOUT, flock$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*flock)(const char *, struct fuse_file_info *, int)
     * }
     */
    public static void flock(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(flock$LAYOUT, flock$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*fallocate)(const char *, int, off_t, off_t, struct fuse_file_info *)
     * }
     */
    public static class fallocate {

        fallocate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, long _x2, long _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_INT,
            fuse_h.C_POINTER,
            fuse_h.C_INT,
            fuse_h.C_LONG,
            fuse_h.C_LONG,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(fallocate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(fallocate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, long _x2, long _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout fallocate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("fallocate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*fallocate)(const char *, int, off_t, off_t, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout fallocate$layout() {
        return fallocate$LAYOUT;
    }

    private static final long fallocate$OFFSET = 312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*fallocate)(const char *, int, off_t, off_t, struct fuse_file_info *)
     * }
     */
    public static final long fallocate$offset() {
        return fallocate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*fallocate)(const char *, int, off_t, off_t, struct fuse_file_info *)
     * }
     */
    public static MemorySegment fallocate(MemorySegment struct) {
        return struct.get(fallocate$LAYOUT, fallocate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*fallocate)(const char *, int, off_t, off_t, struct fuse_file_info *)
     * }
     */
    public static void fallocate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(fallocate$LAYOUT, fallocate$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ssize_t (*copy_file_range)(const char *, struct fuse_file_info *, off_t, const char *, struct fuse_file_info *, off_t, size_t, int)
     * }
     */
    public static class copy_file_range {

        copy_file_range() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4, long _x5, long _x6, int _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_LONG,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_LONG,
            fuse_h.C_POINTER,
            fuse_h.C_POINTER,
            fuse_h.C_LONG,
            fuse_h.C_LONG,
            fuse_h.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(copy_file_range.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(copy_file_range.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4, long _x5, long _x6, int _x7) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout copy_file_range$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("copy_file_range"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ssize_t (*copy_file_range)(const char *, struct fuse_file_info *, off_t, const char *, struct fuse_file_info *, off_t, size_t, int)
     * }
     */
    public static final AddressLayout copy_file_range$layout() {
        return copy_file_range$LAYOUT;
    }

    private static final long copy_file_range$OFFSET = 320;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ssize_t (*copy_file_range)(const char *, struct fuse_file_info *, off_t, const char *, struct fuse_file_info *, off_t, size_t, int)
     * }
     */
    public static final long copy_file_range$offset() {
        return copy_file_range$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ssize_t (*copy_file_range)(const char *, struct fuse_file_info *, off_t, const char *, struct fuse_file_info *, off_t, size_t, int)
     * }
     */
    public static MemorySegment copy_file_range(MemorySegment struct) {
        return struct.get(copy_file_range$LAYOUT, copy_file_range$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ssize_t (*copy_file_range)(const char *, struct fuse_file_info *, off_t, const char *, struct fuse_file_info *, off_t, size_t, int)
     * }
     */
    public static void copy_file_range(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(copy_file_range$LAYOUT, copy_file_range$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * off_t (*lseek)(const char *, off_t, int, struct fuse_file_info *)
     * }
     */
    public static class lseek {

        lseek() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0, long _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            fuse_h.C_LONG,
            fuse_h.C_POINTER,
            fuse_h.C_LONG,
            fuse_h.C_INT,
            fuse_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = fuse_h.upcallHandle(lseek.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(lseek.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, int _x2, MemorySegment _x3) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout lseek$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("lseek"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * off_t (*lseek)(const char *, off_t, int, struct fuse_file_info *)
     * }
     */
    public static final AddressLayout lseek$layout() {
        return lseek$LAYOUT;
    }

    private static final long lseek$OFFSET = 328;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * off_t (*lseek)(const char *, off_t, int, struct fuse_file_info *)
     * }
     */
    public static final long lseek$offset() {
        return lseek$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * off_t (*lseek)(const char *, off_t, int, struct fuse_file_info *)
     * }
     */
    public static MemorySegment lseek(MemorySegment struct) {
        return struct.get(lseek$LAYOUT, lseek$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * off_t (*lseek)(const char *, off_t, int, struct fuse_file_info *)
     * }
     */
    public static void lseek(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(lseek$LAYOUT, lseek$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction) (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

