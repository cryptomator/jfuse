// Generated by jextract

package org.cryptomator.jfuse.mac.extr.fuse;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
/**
 * {@snippet :
 * struct fuse_operations {
 *     int (*getattr)(char*,struct stat*);
 *     int (*readlink)(char*,char*,size_t);
 *     int (*getdir)(char*,fuse_dirh_t,fuse_dirfil_t);
 *     int (*mknod)(char*,mode_t,dev_t);
 *     int (*mkdir)(char*,mode_t);
 *     int (*unlink)(char*);
 *     int (*rmdir)(char*);
 *     int (*symlink)(char*,char*);
 *     int (*rename)(char*,char*);
 *     int (*link)(char*,char*);
 *     int (*chmod)(char*,mode_t);
 *     int (*chown)(char*,uid_t,gid_t);
 *     int (*truncate)(char*,off_t);
 *     int (*utime)(char*,struct utimbuf*);
 *     int (*open)(char*,struct fuse_file_info*);
 *     int (*read)(char*,char*,size_t,off_t,struct fuse_file_info*);
 *     int (*write)(char*,char*,size_t,off_t,struct fuse_file_info*);
 *     int (*statfs)(char*,struct statvfs*);
 *     int (*flush)(char*,struct fuse_file_info*);
 *     int (*release)(char*,struct fuse_file_info*);
 *     int (*fsync)(char*,int,struct fuse_file_info*);
 *     int (*setxattr)(char*,char*,char*,size_t,int);
 *     int (*getxattr)(char*,char*,char*,size_t);
 *     int (*listxattr)(char*,char*,size_t);
 *     int (*removexattr)(char*,char*);
 *     int (*opendir)(char*,struct fuse_file_info*);
 *     int (*readdir)(char*,void*,fuse_fill_dir_t,off_t,struct fuse_file_info*);
 *     int (*releasedir)(char*,struct fuse_file_info*);
 *     int (*fsyncdir)(char*,int,struct fuse_file_info*);
 *     void* (*init)(struct fuse_conn_info*);
 *     void (*destroy)(void*);
 *     int (*access)(char*,int);
 *     int (*create)(char*,mode_t,struct fuse_file_info*);
 *     int (*ftruncate)(char*,off_t,struct fuse_file_info*);
 *     int (*fgetattr)(char*,struct stat*,struct fuse_file_info*);
 *     int (*lock)(char*,struct fuse_file_info*,int,struct flock*);
 *     int (*utimens)(char*,struct timespec*);
 *     int (*bmap)(char*,size_t,uint64_t*);
 *      *     unsigned int flag_nullpath_ok;
 *     unsigned int flag_nopath;
 *     unsigned int flag_utime_omit_ok;
 *     unsigned int flag_reserved;
 *     int (*ioctl)(char*,int,void*,struct fuse_file_info*,unsigned int,void*);
 *     int (*poll)(char*,struct fuse_file_info*,struct fuse_pollhandle*,unsigned int*);
 *     int (*write_buf)(char*,struct fuse_bufvec*,off_t,struct fuse_file_info*);
 *     int (*read_buf)(char*,struct fuse_bufvec**,size_t,off_t,struct fuse_file_info*);
 *     int (*flock)(char*,struct fuse_file_info*,int);
 *     int (*fallocate)(char*,int,off_t,off_t,struct fuse_file_info*);
 * };
 * }
 */
public class fuse_operations {

    public static MemoryLayout $LAYOUT() {
        return constants$9.const$4;
    }
    /**
     * {@snippet :
 * int (*getattr)(char*,struct stat*);
     * }
     */
    public interface getattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(getattr fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$10.const$0, fi, constants$9.const$5, scope);
        }
        static getattr ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)constants$10.const$1.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle getattr$VH() {
        return constants$10.const$2;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*getattr)(char*,struct stat*);
     * }
     */
    public static MemorySegment getattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$10.const$2.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*getattr)(char*,struct stat*);
     * }
     */
    public static void getattr$set(MemorySegment seg, MemorySegment x) {
        constants$10.const$2.set(seg, x);
    }
    public static MemorySegment getattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$10.const$2.get(seg.asSlice(index*sizeof()));
    }
    public static void getattr$set(MemorySegment seg, long index, MemorySegment x) {
        constants$10.const$2.set(seg.asSlice(index*sizeof()), x);
    }
    public static getattr getattr(MemorySegment segment, Arena scope) {
        return getattr.ofAddress(getattr$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*readlink)(char*,char*,size_t);
     * }
     */
    public interface readlink {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2);
        static MemorySegment allocate(readlink fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$10.const$4, fi, constants$10.const$3, scope);
        }
        static readlink ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2) -> {
                try {
                    return (int)constants$10.const$5.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle readlink$VH() {
        return constants$11.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*readlink)(char*,char*,size_t);
     * }
     */
    public static MemorySegment readlink$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$11.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*readlink)(char*,char*,size_t);
     * }
     */
    public static void readlink$set(MemorySegment seg, MemorySegment x) {
        constants$11.const$0.set(seg, x);
    }
    public static MemorySegment readlink$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$11.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void readlink$set(MemorySegment seg, long index, MemorySegment x) {
        constants$11.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static readlink readlink(MemorySegment segment, Arena scope) {
        return readlink.ofAddress(readlink$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*getdir)(char*,fuse_dirh_t,fuse_dirfil_t);
     * }
     */
    public interface getdir {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(getdir fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$11.const$2, fi, constants$11.const$1, scope);
        }
        static getdir ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)constants$11.const$3.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle getdir$VH() {
        return constants$11.const$4;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*getdir)(char*,fuse_dirh_t,fuse_dirfil_t);
     * }
     */
    public static MemorySegment getdir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$11.const$4.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*getdir)(char*,fuse_dirh_t,fuse_dirfil_t);
     * }
     */
    public static void getdir$set(MemorySegment seg, MemorySegment x) {
        constants$11.const$4.set(seg, x);
    }
    public static MemorySegment getdir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$11.const$4.get(seg.asSlice(index*sizeof()));
    }
    public static void getdir$set(MemorySegment seg, long index, MemorySegment x) {
        constants$11.const$4.set(seg.asSlice(index*sizeof()), x);
    }
    public static getdir getdir(MemorySegment segment, Arena scope) {
        return getdir.ofAddress(getdir$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*mknod)(char*,mode_t,dev_t);
     * }
     */
    public interface mknod {

        int apply(java.lang.foreign.MemorySegment _x0, short _x1, int _x2);
        static MemorySegment allocate(mknod fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$12.const$0, fi, constants$11.const$5, scope);
        }
        static mknod ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, short __x1, int __x2) -> {
                try {
                    return (int)constants$12.const$1.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle mknod$VH() {
        return constants$12.const$2;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*mknod)(char*,mode_t,dev_t);
     * }
     */
    public static MemorySegment mknod$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$12.const$2.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*mknod)(char*,mode_t,dev_t);
     * }
     */
    public static void mknod$set(MemorySegment seg, MemorySegment x) {
        constants$12.const$2.set(seg, x);
    }
    public static MemorySegment mknod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$12.const$2.get(seg.asSlice(index*sizeof()));
    }
    public static void mknod$set(MemorySegment seg, long index, MemorySegment x) {
        constants$12.const$2.set(seg.asSlice(index*sizeof()), x);
    }
    public static mknod mknod(MemorySegment segment, Arena scope) {
        return mknod.ofAddress(mknod$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*mkdir)(char*,mode_t);
     * }
     */
    public interface mkdir {

        int apply(java.lang.foreign.MemorySegment _x0, short _x1);
        static MemorySegment allocate(mkdir fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$12.const$4, fi, constants$12.const$3, scope);
        }
        static mkdir ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, short __x1) -> {
                try {
                    return (int)constants$12.const$5.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle mkdir$VH() {
        return constants$13.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*mkdir)(char*,mode_t);
     * }
     */
    public static MemorySegment mkdir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$13.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*mkdir)(char*,mode_t);
     * }
     */
    public static void mkdir$set(MemorySegment seg, MemorySegment x) {
        constants$13.const$0.set(seg, x);
    }
    public static MemorySegment mkdir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$13.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void mkdir$set(MemorySegment seg, long index, MemorySegment x) {
        constants$13.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static mkdir mkdir(MemorySegment segment, Arena scope) {
        return mkdir.ofAddress(mkdir$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*unlink)(char*);
     * }
     */
    public interface unlink {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(unlink fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$13.const$2, fi, constants$13.const$1, scope);
        }
        static unlink ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)constants$13.const$3.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle unlink$VH() {
        return constants$13.const$4;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*unlink)(char*);
     * }
     */
    public static MemorySegment unlink$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$13.const$4.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*unlink)(char*);
     * }
     */
    public static void unlink$set(MemorySegment seg, MemorySegment x) {
        constants$13.const$4.set(seg, x);
    }
    public static MemorySegment unlink$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$13.const$4.get(seg.asSlice(index*sizeof()));
    }
    public static void unlink$set(MemorySegment seg, long index, MemorySegment x) {
        constants$13.const$4.set(seg.asSlice(index*sizeof()), x);
    }
    public static unlink unlink(MemorySegment segment, Arena scope) {
        return unlink.ofAddress(unlink$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*rmdir)(char*);
     * }
     */
    public interface rmdir {

        int apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(rmdir fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$13.const$5, fi, constants$13.const$1, scope);
        }
        static rmdir ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (int)constants$13.const$3.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle rmdir$VH() {
        return constants$14.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*rmdir)(char*);
     * }
     */
    public static MemorySegment rmdir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$14.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*rmdir)(char*);
     * }
     */
    public static void rmdir$set(MemorySegment seg, MemorySegment x) {
        constants$14.const$0.set(seg, x);
    }
    public static MemorySegment rmdir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$14.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void rmdir$set(MemorySegment seg, long index, MemorySegment x) {
        constants$14.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static rmdir rmdir(MemorySegment segment, Arena scope) {
        return rmdir.ofAddress(rmdir$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*symlink)(char*,char*);
     * }
     */
    public interface symlink {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(symlink fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$14.const$1, fi, constants$9.const$5, scope);
        }
        static symlink ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)constants$10.const$1.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle symlink$VH() {
        return constants$14.const$2;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*symlink)(char*,char*);
     * }
     */
    public static MemorySegment symlink$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$14.const$2.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*symlink)(char*,char*);
     * }
     */
    public static void symlink$set(MemorySegment seg, MemorySegment x) {
        constants$14.const$2.set(seg, x);
    }
    public static MemorySegment symlink$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$14.const$2.get(seg.asSlice(index*sizeof()));
    }
    public static void symlink$set(MemorySegment seg, long index, MemorySegment x) {
        constants$14.const$2.set(seg.asSlice(index*sizeof()), x);
    }
    public static symlink symlink(MemorySegment segment, Arena scope) {
        return symlink.ofAddress(symlink$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*rename)(char*,char*);
     * }
     */
    public interface rename {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(rename fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$14.const$3, fi, constants$9.const$5, scope);
        }
        static rename ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)constants$10.const$1.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle rename$VH() {
        return constants$14.const$4;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*rename)(char*,char*);
     * }
     */
    public static MemorySegment rename$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$14.const$4.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*rename)(char*,char*);
     * }
     */
    public static void rename$set(MemorySegment seg, MemorySegment x) {
        constants$14.const$4.set(seg, x);
    }
    public static MemorySegment rename$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$14.const$4.get(seg.asSlice(index*sizeof()));
    }
    public static void rename$set(MemorySegment seg, long index, MemorySegment x) {
        constants$14.const$4.set(seg.asSlice(index*sizeof()), x);
    }
    public static rename rename(MemorySegment segment, Arena scope) {
        return rename.ofAddress(rename$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*link)(char*,char*);
     * }
     */
    public interface link {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(link fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$14.const$5, fi, constants$9.const$5, scope);
        }
        static link ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)constants$10.const$1.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle link$VH() {
        return constants$15.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*link)(char*,char*);
     * }
     */
    public static MemorySegment link$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$15.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*link)(char*,char*);
     * }
     */
    public static void link$set(MemorySegment seg, MemorySegment x) {
        constants$15.const$0.set(seg, x);
    }
    public static MemorySegment link$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$15.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void link$set(MemorySegment seg, long index, MemorySegment x) {
        constants$15.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static link link(MemorySegment segment, Arena scope) {
        return link.ofAddress(link$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*chmod)(char*,mode_t);
     * }
     */
    public interface chmod {

        int apply(java.lang.foreign.MemorySegment _x0, short _x1);
        static MemorySegment allocate(chmod fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$15.const$1, fi, constants$12.const$3, scope);
        }
        static chmod ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, short __x1) -> {
                try {
                    return (int)constants$12.const$5.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle chmod$VH() {
        return constants$15.const$2;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*chmod)(char*,mode_t);
     * }
     */
    public static MemorySegment chmod$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$15.const$2.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*chmod)(char*,mode_t);
     * }
     */
    public static void chmod$set(MemorySegment seg, MemorySegment x) {
        constants$15.const$2.set(seg, x);
    }
    public static MemorySegment chmod$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$15.const$2.get(seg.asSlice(index*sizeof()));
    }
    public static void chmod$set(MemorySegment seg, long index, MemorySegment x) {
        constants$15.const$2.set(seg.asSlice(index*sizeof()), x);
    }
    public static chmod chmod(MemorySegment segment, Arena scope) {
        return chmod.ofAddress(chmod$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*chown)(char*,uid_t,gid_t);
     * }
     */
    public interface chown {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, int _x2);
        static MemorySegment allocate(chown fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$15.const$4, fi, constants$15.const$3, scope);
        }
        static chown ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, int __x1, int __x2) -> {
                try {
                    return (int)constants$15.const$5.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle chown$VH() {
        return constants$16.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*chown)(char*,uid_t,gid_t);
     * }
     */
    public static MemorySegment chown$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$16.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*chown)(char*,uid_t,gid_t);
     * }
     */
    public static void chown$set(MemorySegment seg, MemorySegment x) {
        constants$16.const$0.set(seg, x);
    }
    public static MemorySegment chown$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$16.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void chown$set(MemorySegment seg, long index, MemorySegment x) {
        constants$16.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static chown chown(MemorySegment segment, Arena scope) {
        return chown.ofAddress(chown$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*truncate)(char*,off_t);
     * }
     */
    public interface truncate {

        int apply(java.lang.foreign.MemorySegment _x0, long _x1);
        static MemorySegment allocate(truncate fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$16.const$2, fi, constants$16.const$1, scope);
        }
        static truncate ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, long __x1) -> {
                try {
                    return (int)constants$16.const$3.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle truncate$VH() {
        return constants$16.const$4;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*truncate)(char*,off_t);
     * }
     */
    public static MemorySegment truncate$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$16.const$4.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*truncate)(char*,off_t);
     * }
     */
    public static void truncate$set(MemorySegment seg, MemorySegment x) {
        constants$16.const$4.set(seg, x);
    }
    public static MemorySegment truncate$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$16.const$4.get(seg.asSlice(index*sizeof()));
    }
    public static void truncate$set(MemorySegment seg, long index, MemorySegment x) {
        constants$16.const$4.set(seg.asSlice(index*sizeof()), x);
    }
    public static truncate truncate(MemorySegment segment, Arena scope) {
        return truncate.ofAddress(truncate$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*utime)(char*,struct utimbuf*);
     * }
     */
    public interface utime {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(utime fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$16.const$5, fi, constants$9.const$5, scope);
        }
        static utime ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)constants$10.const$1.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle utime$VH() {
        return constants$17.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*utime)(char*,struct utimbuf*);
     * }
     */
    public static MemorySegment utime$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$17.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*utime)(char*,struct utimbuf*);
     * }
     */
    public static void utime$set(MemorySegment seg, MemorySegment x) {
        constants$17.const$0.set(seg, x);
    }
    public static MemorySegment utime$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$17.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void utime$set(MemorySegment seg, long index, MemorySegment x) {
        constants$17.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static utime utime(MemorySegment segment, Arena scope) {
        return utime.ofAddress(utime$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*open)(char*,struct fuse_file_info*);
     * }
     */
    public interface open {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(open fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$17.const$1, fi, constants$9.const$5, scope);
        }
        static open ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)constants$10.const$1.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle open$VH() {
        return constants$17.const$2;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*open)(char*,struct fuse_file_info*);
     * }
     */
    public static MemorySegment open$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$17.const$2.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*open)(char*,struct fuse_file_info*);
     * }
     */
    public static void open$set(MemorySegment seg, MemorySegment x) {
        constants$17.const$2.set(seg, x);
    }
    public static MemorySegment open$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$17.const$2.get(seg.asSlice(index*sizeof()));
    }
    public static void open$set(MemorySegment seg, long index, MemorySegment x) {
        constants$17.const$2.set(seg.asSlice(index*sizeof()), x);
    }
    public static open open(MemorySegment segment, Arena scope) {
        return open.ofAddress(open$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*read)(char*,char*,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public interface read {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2, long _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(read fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$17.const$4, fi, constants$17.const$3, scope);
        }
        static read ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2, long __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)constants$17.const$5.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle read$VH() {
        return constants$18.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*read)(char*,char*,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment read$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$18.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*read)(char*,char*,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public static void read$set(MemorySegment seg, MemorySegment x) {
        constants$18.const$0.set(seg, x);
    }
    public static MemorySegment read$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$18.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void read$set(MemorySegment seg, long index, MemorySegment x) {
        constants$18.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static read read(MemorySegment segment, Arena scope) {
        return read.ofAddress(read$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*write)(char*,char*,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public interface write {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2, long _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(write fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$18.const$1, fi, constants$17.const$3, scope);
        }
        static write ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2, long __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)constants$17.const$5.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle write$VH() {
        return constants$18.const$2;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*write)(char*,char*,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment write$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$18.const$2.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*write)(char*,char*,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public static void write$set(MemorySegment seg, MemorySegment x) {
        constants$18.const$2.set(seg, x);
    }
    public static MemorySegment write$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$18.const$2.get(seg.asSlice(index*sizeof()));
    }
    public static void write$set(MemorySegment seg, long index, MemorySegment x) {
        constants$18.const$2.set(seg.asSlice(index*sizeof()), x);
    }
    public static write write(MemorySegment segment, Arena scope) {
        return write.ofAddress(write$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*statfs)(char*,struct statvfs*);
     * }
     */
    public interface statfs {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(statfs fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$18.const$3, fi, constants$9.const$5, scope);
        }
        static statfs ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)constants$10.const$1.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle statfs$VH() {
        return constants$18.const$4;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*statfs)(char*,struct statvfs*);
     * }
     */
    public static MemorySegment statfs$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$18.const$4.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*statfs)(char*,struct statvfs*);
     * }
     */
    public static void statfs$set(MemorySegment seg, MemorySegment x) {
        constants$18.const$4.set(seg, x);
    }
    public static MemorySegment statfs$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$18.const$4.get(seg.asSlice(index*sizeof()));
    }
    public static void statfs$set(MemorySegment seg, long index, MemorySegment x) {
        constants$18.const$4.set(seg.asSlice(index*sizeof()), x);
    }
    public static statfs statfs(MemorySegment segment, Arena scope) {
        return statfs.ofAddress(statfs$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*flush)(char*,struct fuse_file_info*);
     * }
     */
    public interface flush {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(flush fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$18.const$5, fi, constants$9.const$5, scope);
        }
        static flush ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)constants$10.const$1.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle flush$VH() {
        return constants$19.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*flush)(char*,struct fuse_file_info*);
     * }
     */
    public static MemorySegment flush$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$19.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*flush)(char*,struct fuse_file_info*);
     * }
     */
    public static void flush$set(MemorySegment seg, MemorySegment x) {
        constants$19.const$0.set(seg, x);
    }
    public static MemorySegment flush$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$19.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void flush$set(MemorySegment seg, long index, MemorySegment x) {
        constants$19.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static flush flush(MemorySegment segment, Arena scope) {
        return flush.ofAddress(flush$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*release)(char*,struct fuse_file_info*);
     * }
     */
    public interface release {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(release fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$19.const$1, fi, constants$9.const$5, scope);
        }
        static release ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)constants$10.const$1.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle release$VH() {
        return constants$19.const$2;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*release)(char*,struct fuse_file_info*);
     * }
     */
    public static MemorySegment release$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$19.const$2.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*release)(char*,struct fuse_file_info*);
     * }
     */
    public static void release$set(MemorySegment seg, MemorySegment x) {
        constants$19.const$2.set(seg, x);
    }
    public static MemorySegment release$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$19.const$2.get(seg.asSlice(index*sizeof()));
    }
    public static void release$set(MemorySegment seg, long index, MemorySegment x) {
        constants$19.const$2.set(seg.asSlice(index*sizeof()), x);
    }
    public static release release(MemorySegment segment, Arena scope) {
        return release.ofAddress(release$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*fsync)(char*,int,struct fuse_file_info*);
     * }
     */
    public interface fsync {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(fsync fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$19.const$4, fi, constants$19.const$3, scope);
        }
        static fsync ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)constants$19.const$5.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle fsync$VH() {
        return constants$20.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*fsync)(char*,int,struct fuse_file_info*);
     * }
     */
    public static MemorySegment fsync$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$20.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*fsync)(char*,int,struct fuse_file_info*);
     * }
     */
    public static void fsync$set(MemorySegment seg, MemorySegment x) {
        constants$20.const$0.set(seg, x);
    }
    public static MemorySegment fsync$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$20.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void fsync$set(MemorySegment seg, long index, MemorySegment x) {
        constants$20.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static fsync fsync(MemorySegment segment, Arena scope) {
        return fsync.ofAddress(fsync$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*setxattr)(char*,char*,char*,size_t,int);
     * }
     */
    public interface setxattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, long _x3, int _x4);
        static MemorySegment allocate(setxattr fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$20.const$2, fi, constants$20.const$1, scope);
        }
        static setxattr ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, long __x3, int __x4) -> {
                try {
                    return (int)constants$20.const$3.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle setxattr$VH() {
        return constants$20.const$4;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*setxattr)(char*,char*,char*,size_t,int);
     * }
     */
    public static MemorySegment setxattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$20.const$4.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*setxattr)(char*,char*,char*,size_t,int);
     * }
     */
    public static void setxattr$set(MemorySegment seg, MemorySegment x) {
        constants$20.const$4.set(seg, x);
    }
    public static MemorySegment setxattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$20.const$4.get(seg.asSlice(index*sizeof()));
    }
    public static void setxattr$set(MemorySegment seg, long index, MemorySegment x) {
        constants$20.const$4.set(seg.asSlice(index*sizeof()), x);
    }
    public static setxattr setxattr(MemorySegment segment, Arena scope) {
        return setxattr.ofAddress(setxattr$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*getxattr)(char*,char*,char*,size_t);
     * }
     */
    public interface getxattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, long _x3);
        static MemorySegment allocate(getxattr fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$20.const$5, fi, constants$9.const$1, scope);
        }
        static getxattr ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, long __x3) -> {
                try {
                    return (int)constants$9.const$3.invokeExact(symbol, __x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle getxattr$VH() {
        return constants$21.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*getxattr)(char*,char*,char*,size_t);
     * }
     */
    public static MemorySegment getxattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$21.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*getxattr)(char*,char*,char*,size_t);
     * }
     */
    public static void getxattr$set(MemorySegment seg, MemorySegment x) {
        constants$21.const$0.set(seg, x);
    }
    public static MemorySegment getxattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$21.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void getxattr$set(MemorySegment seg, long index, MemorySegment x) {
        constants$21.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static getxattr getxattr(MemorySegment segment, Arena scope) {
        return getxattr.ofAddress(getxattr$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*listxattr)(char*,char*,size_t);
     * }
     */
    public interface listxattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2);
        static MemorySegment allocate(listxattr fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$21.const$1, fi, constants$10.const$3, scope);
        }
        static listxattr ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2) -> {
                try {
                    return (int)constants$10.const$5.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle listxattr$VH() {
        return constants$21.const$2;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*listxattr)(char*,char*,size_t);
     * }
     */
    public static MemorySegment listxattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$21.const$2.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*listxattr)(char*,char*,size_t);
     * }
     */
    public static void listxattr$set(MemorySegment seg, MemorySegment x) {
        constants$21.const$2.set(seg, x);
    }
    public static MemorySegment listxattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$21.const$2.get(seg.asSlice(index*sizeof()));
    }
    public static void listxattr$set(MemorySegment seg, long index, MemorySegment x) {
        constants$21.const$2.set(seg.asSlice(index*sizeof()), x);
    }
    public static listxattr listxattr(MemorySegment segment, Arena scope) {
        return listxattr.ofAddress(listxattr$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*removexattr)(char*,char*);
     * }
     */
    public interface removexattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(removexattr fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$21.const$3, fi, constants$9.const$5, scope);
        }
        static removexattr ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)constants$10.const$1.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle removexattr$VH() {
        return constants$21.const$4;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*removexattr)(char*,char*);
     * }
     */
    public static MemorySegment removexattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$21.const$4.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*removexattr)(char*,char*);
     * }
     */
    public static void removexattr$set(MemorySegment seg, MemorySegment x) {
        constants$21.const$4.set(seg, x);
    }
    public static MemorySegment removexattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$21.const$4.get(seg.asSlice(index*sizeof()));
    }
    public static void removexattr$set(MemorySegment seg, long index, MemorySegment x) {
        constants$21.const$4.set(seg.asSlice(index*sizeof()), x);
    }
    public static removexattr removexattr(MemorySegment segment, Arena scope) {
        return removexattr.ofAddress(removexattr$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*opendir)(char*,struct fuse_file_info*);
     * }
     */
    public interface opendir {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(opendir fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$21.const$5, fi, constants$9.const$5, scope);
        }
        static opendir ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)constants$10.const$1.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle opendir$VH() {
        return constants$22.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*opendir)(char*,struct fuse_file_info*);
     * }
     */
    public static MemorySegment opendir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$22.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*opendir)(char*,struct fuse_file_info*);
     * }
     */
    public static void opendir$set(MemorySegment seg, MemorySegment x) {
        constants$22.const$0.set(seg, x);
    }
    public static MemorySegment opendir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$22.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void opendir$set(MemorySegment seg, long index, MemorySegment x) {
        constants$22.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static opendir opendir(MemorySegment segment, Arena scope) {
        return opendir.ofAddress(opendir$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*readdir)(char*,void*,fuse_fill_dir_t,off_t,struct fuse_file_info*);
     * }
     */
    public interface readdir {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, long _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(readdir fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$22.const$2, fi, constants$22.const$1, scope);
        }
        static readdir ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, long __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)constants$22.const$3.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle readdir$VH() {
        return constants$22.const$4;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*readdir)(char*,void*,fuse_fill_dir_t,off_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment readdir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$22.const$4.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*readdir)(char*,void*,fuse_fill_dir_t,off_t,struct fuse_file_info*);
     * }
     */
    public static void readdir$set(MemorySegment seg, MemorySegment x) {
        constants$22.const$4.set(seg, x);
    }
    public static MemorySegment readdir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$22.const$4.get(seg.asSlice(index*sizeof()));
    }
    public static void readdir$set(MemorySegment seg, long index, MemorySegment x) {
        constants$22.const$4.set(seg.asSlice(index*sizeof()), x);
    }
    public static readdir readdir(MemorySegment segment, Arena scope) {
        return readdir.ofAddress(readdir$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*releasedir)(char*,struct fuse_file_info*);
     * }
     */
    public interface releasedir {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(releasedir fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$22.const$5, fi, constants$9.const$5, scope);
        }
        static releasedir ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)constants$10.const$1.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle releasedir$VH() {
        return constants$23.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*releasedir)(char*,struct fuse_file_info*);
     * }
     */
    public static MemorySegment releasedir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$23.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*releasedir)(char*,struct fuse_file_info*);
     * }
     */
    public static void releasedir$set(MemorySegment seg, MemorySegment x) {
        constants$23.const$0.set(seg, x);
    }
    public static MemorySegment releasedir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$23.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void releasedir$set(MemorySegment seg, long index, MemorySegment x) {
        constants$23.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static releasedir releasedir(MemorySegment segment, Arena scope) {
        return releasedir.ofAddress(releasedir$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*fsyncdir)(char*,int,struct fuse_file_info*);
     * }
     */
    public interface fsyncdir {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(fsyncdir fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$23.const$1, fi, constants$19.const$3, scope);
        }
        static fsyncdir ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)constants$19.const$5.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle fsyncdir$VH() {
        return constants$23.const$2;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*fsyncdir)(char*,int,struct fuse_file_info*);
     * }
     */
    public static MemorySegment fsyncdir$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$23.const$2.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*fsyncdir)(char*,int,struct fuse_file_info*);
     * }
     */
    public static void fsyncdir$set(MemorySegment seg, MemorySegment x) {
        constants$23.const$2.set(seg, x);
    }
    public static MemorySegment fsyncdir$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$23.const$2.get(seg.asSlice(index*sizeof()));
    }
    public static void fsyncdir$set(MemorySegment seg, long index, MemorySegment x) {
        constants$23.const$2.set(seg.asSlice(index*sizeof()), x);
    }
    public static fsyncdir fsyncdir(MemorySegment segment, Arena scope) {
        return fsyncdir.ofAddress(fsyncdir$get(segment), scope);
    }
    /**
     * {@snippet :
 * void* (*init)(struct fuse_conn_info*);
     * }
     */
    public interface init {

        java.lang.foreign.MemorySegment apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(init fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$23.const$4, fi, constants$23.const$3, scope);
        }
        static init ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    return (java.lang.foreign.MemorySegment)constants$23.const$5.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle init$VH() {
        return constants$24.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * void* (*init)(struct fuse_conn_info*);
     * }
     */
    public static MemorySegment init$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$24.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * void* (*init)(struct fuse_conn_info*);
     * }
     */
    public static void init$set(MemorySegment seg, MemorySegment x) {
        constants$24.const$0.set(seg, x);
    }
    public static MemorySegment init$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$24.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void init$set(MemorySegment seg, long index, MemorySegment x) {
        constants$24.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static init init(MemorySegment segment, Arena scope) {
        return init.ofAddress(init$get(segment), scope);
    }
    /**
     * {@snippet :
 * void (*destroy)(void*);
     * }
     */
    public interface destroy {

        void apply(java.lang.foreign.MemorySegment _x0);
        static MemorySegment allocate(destroy fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$24.const$2, fi, constants$24.const$1, scope);
        }
        static destroy ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0) -> {
                try {
                    constants$24.const$3.invokeExact(symbol, __x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle destroy$VH() {
        return constants$24.const$4;
    }
    /**
     * Getter for field:
     * {@snippet :
     * void (*destroy)(void*);
     * }
     */
    public static MemorySegment destroy$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$24.const$4.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * void (*destroy)(void*);
     * }
     */
    public static void destroy$set(MemorySegment seg, MemorySegment x) {
        constants$24.const$4.set(seg, x);
    }
    public static MemorySegment destroy$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$24.const$4.get(seg.asSlice(index*sizeof()));
    }
    public static void destroy$set(MemorySegment seg, long index, MemorySegment x) {
        constants$24.const$4.set(seg.asSlice(index*sizeof()), x);
    }
    public static destroy destroy(MemorySegment segment, Arena scope) {
        return destroy.ofAddress(destroy$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*access)(char*,int);
     * }
     */
    public interface access {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1);
        static MemorySegment allocate(access fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$25.const$0, fi, constants$24.const$5, scope);
        }
        static access ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, int __x1) -> {
                try {
                    return (int)constants$25.const$1.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle access$VH() {
        return constants$25.const$2;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*access)(char*,int);
     * }
     */
    public static MemorySegment access$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$25.const$2.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*access)(char*,int);
     * }
     */
    public static void access$set(MemorySegment seg, MemorySegment x) {
        constants$25.const$2.set(seg, x);
    }
    public static MemorySegment access$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$25.const$2.get(seg.asSlice(index*sizeof()));
    }
    public static void access$set(MemorySegment seg, long index, MemorySegment x) {
        constants$25.const$2.set(seg.asSlice(index*sizeof()), x);
    }
    public static access access(MemorySegment segment, Arena scope) {
        return access.ofAddress(access$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*create)(char*,mode_t,struct fuse_file_info*);
     * }
     */
    public interface create {

        int apply(java.lang.foreign.MemorySegment _x0, short _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(create fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$25.const$4, fi, constants$25.const$3, scope);
        }
        static create ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, short __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)constants$25.const$5.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle create$VH() {
        return constants$26.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*create)(char*,mode_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment create$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$26.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*create)(char*,mode_t,struct fuse_file_info*);
     * }
     */
    public static void create$set(MemorySegment seg, MemorySegment x) {
        constants$26.const$0.set(seg, x);
    }
    public static MemorySegment create$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$26.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void create$set(MemorySegment seg, long index, MemorySegment x) {
        constants$26.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static create create(MemorySegment segment, Arena scope) {
        return create.ofAddress(create$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*ftruncate)(char*,off_t,struct fuse_file_info*);
     * }
     */
    public interface ftruncate {

        int apply(java.lang.foreign.MemorySegment _x0, long _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(ftruncate fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$26.const$2, fi, constants$26.const$1, scope);
        }
        static ftruncate ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, long __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)constants$26.const$3.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle ftruncate$VH() {
        return constants$26.const$4;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*ftruncate)(char*,off_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment ftruncate$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$26.const$4.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*ftruncate)(char*,off_t,struct fuse_file_info*);
     * }
     */
    public static void ftruncate$set(MemorySegment seg, MemorySegment x) {
        constants$26.const$4.set(seg, x);
    }
    public static MemorySegment ftruncate$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$26.const$4.get(seg.asSlice(index*sizeof()));
    }
    public static void ftruncate$set(MemorySegment seg, long index, MemorySegment x) {
        constants$26.const$4.set(seg.asSlice(index*sizeof()), x);
    }
    public static ftruncate ftruncate(MemorySegment segment, Arena scope) {
        return ftruncate.ofAddress(ftruncate$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*fgetattr)(char*,struct stat*,struct fuse_file_info*);
     * }
     */
    public interface fgetattr {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(fgetattr fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$26.const$5, fi, constants$11.const$1, scope);
        }
        static fgetattr ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)constants$11.const$3.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle fgetattr$VH() {
        return constants$27.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*fgetattr)(char*,struct stat*,struct fuse_file_info*);
     * }
     */
    public static MemorySegment fgetattr$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$27.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*fgetattr)(char*,struct stat*,struct fuse_file_info*);
     * }
     */
    public static void fgetattr$set(MemorySegment seg, MemorySegment x) {
        constants$27.const$0.set(seg, x);
    }
    public static MemorySegment fgetattr$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$27.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void fgetattr$set(MemorySegment seg, long index, MemorySegment x) {
        constants$27.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static fgetattr fgetattr(MemorySegment segment, Arena scope) {
        return fgetattr.ofAddress(fgetattr$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*lock)(char*,struct fuse_file_info*,int,struct flock*);
     * }
     */
    public interface lock {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, int _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(lock fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$27.const$2, fi, constants$27.const$1, scope);
        }
        static lock ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, int __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    return (int)constants$27.const$3.invokeExact(symbol, __x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle lock$VH() {
        return constants$27.const$4;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*lock)(char*,struct fuse_file_info*,int,struct flock*);
     * }
     */
    public static MemorySegment lock$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$27.const$4.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*lock)(char*,struct fuse_file_info*,int,struct flock*);
     * }
     */
    public static void lock$set(MemorySegment seg, MemorySegment x) {
        constants$27.const$4.set(seg, x);
    }
    public static MemorySegment lock$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$27.const$4.get(seg.asSlice(index*sizeof()));
    }
    public static void lock$set(MemorySegment seg, long index, MemorySegment x) {
        constants$27.const$4.set(seg.asSlice(index*sizeof()), x);
    }
    public static lock lock(MemorySegment segment, Arena scope) {
        return lock.ofAddress(lock$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*utimens)(char*,struct timespec*);
     * }
     */
    public interface utimens {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1);
        static MemorySegment allocate(utimens fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$27.const$5, fi, constants$9.const$5, scope);
        }
        static utimens ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1) -> {
                try {
                    return (int)constants$10.const$1.invokeExact(symbol, __x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle utimens$VH() {
        return constants$28.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*utimens)(char*,struct timespec*);
     * }
     */
    public static MemorySegment utimens$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$28.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*utimens)(char*,struct timespec*);
     * }
     */
    public static void utimens$set(MemorySegment seg, MemorySegment x) {
        constants$28.const$0.set(seg, x);
    }
    public static MemorySegment utimens$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$28.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void utimens$set(MemorySegment seg, long index, MemorySegment x) {
        constants$28.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static utimens utimens(MemorySegment segment, Arena scope) {
        return utimens.ofAddress(utimens$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*bmap)(char*,size_t,uint64_t*);
     * }
     */
    public interface bmap {

        int apply(java.lang.foreign.MemorySegment _x0, long _x1, java.lang.foreign.MemorySegment _x2);
        static MemorySegment allocate(bmap fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$28.const$1, fi, constants$26.const$1, scope);
        }
        static bmap ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, long __x1, java.lang.foreign.MemorySegment __x2) -> {
                try {
                    return (int)constants$26.const$3.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle bmap$VH() {
        return constants$28.const$2;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*bmap)(char*,size_t,uint64_t*);
     * }
     */
    public static MemorySegment bmap$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$28.const$2.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*bmap)(char*,size_t,uint64_t*);
     * }
     */
    public static void bmap$set(MemorySegment seg, MemorySegment x) {
        constants$28.const$2.set(seg, x);
    }
    public static MemorySegment bmap$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$28.const$2.get(seg.asSlice(index*sizeof()));
    }
    public static void bmap$set(MemorySegment seg, long index, MemorySegment x) {
        constants$28.const$2.set(seg.asSlice(index*sizeof()), x);
    }
    public static bmap bmap(MemorySegment segment, Arena scope) {
        return bmap.ofAddress(bmap$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*ioctl)(char*,int,void*,struct fuse_file_info*,unsigned int,void*);
     * }
     */
    public interface ioctl {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3, int _x4, java.lang.foreign.MemorySegment _x5);
        static MemorySegment allocate(ioctl fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$28.const$4, fi, constants$28.const$3, scope);
        }
        static ioctl ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, int __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3, int __x4, java.lang.foreign.MemorySegment __x5) -> {
                try {
                    return (int)constants$28.const$5.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4, __x5);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle ioctl$VH() {
        return constants$29.const$0;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*ioctl)(char*,int,void*,struct fuse_file_info*,unsigned int,void*);
     * }
     */
    public static MemorySegment ioctl$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$29.const$0.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*ioctl)(char*,int,void*,struct fuse_file_info*,unsigned int,void*);
     * }
     */
    public static void ioctl$set(MemorySegment seg, MemorySegment x) {
        constants$29.const$0.set(seg, x);
    }
    public static MemorySegment ioctl$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$29.const$0.get(seg.asSlice(index*sizeof()));
    }
    public static void ioctl$set(MemorySegment seg, long index, MemorySegment x) {
        constants$29.const$0.set(seg.asSlice(index*sizeof()), x);
    }
    public static ioctl ioctl(MemorySegment segment, Arena scope) {
        return ioctl.ofAddress(ioctl$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*poll)(char*,struct fuse_file_info*,struct fuse_pollhandle*,unsigned int*);
     * }
     */
    public interface poll {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, java.lang.foreign.MemorySegment _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(poll fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$29.const$1, fi, constants$4.const$0, scope);
        }
        static poll ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, java.lang.foreign.MemorySegment __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    return (int)constants$29.const$2.invokeExact(symbol, __x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle poll$VH() {
        return constants$29.const$3;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*poll)(char*,struct fuse_file_info*,struct fuse_pollhandle*,unsigned int*);
     * }
     */
    public static MemorySegment poll$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$29.const$3.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*poll)(char*,struct fuse_file_info*,struct fuse_pollhandle*,unsigned int*);
     * }
     */
    public static void poll$set(MemorySegment seg, MemorySegment x) {
        constants$29.const$3.set(seg, x);
    }
    public static MemorySegment poll$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$29.const$3.get(seg.asSlice(index*sizeof()));
    }
    public static void poll$set(MemorySegment seg, long index, MemorySegment x) {
        constants$29.const$3.set(seg.asSlice(index*sizeof()), x);
    }
    public static poll poll(MemorySegment segment, Arena scope) {
        return poll.ofAddress(poll$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*write_buf)(char*,struct fuse_bufvec*,off_t,struct fuse_file_info*);
     * }
     */
    public interface write_buf {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2, java.lang.foreign.MemorySegment _x3);
        static MemorySegment allocate(write_buf fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$29.const$5, fi, constants$29.const$4, scope);
        }
        static write_buf ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2, java.lang.foreign.MemorySegment __x3) -> {
                try {
                    return (int)constants$30.const$0.invokeExact(symbol, __x0, __x1, __x2, __x3);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle write_buf$VH() {
        return constants$30.const$1;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*write_buf)(char*,struct fuse_bufvec*,off_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment write_buf$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$30.const$1.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*write_buf)(char*,struct fuse_bufvec*,off_t,struct fuse_file_info*);
     * }
     */
    public static void write_buf$set(MemorySegment seg, MemorySegment x) {
        constants$30.const$1.set(seg, x);
    }
    public static MemorySegment write_buf$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$30.const$1.get(seg.asSlice(index*sizeof()));
    }
    public static void write_buf$set(MemorySegment seg, long index, MemorySegment x) {
        constants$30.const$1.set(seg.asSlice(index*sizeof()), x);
    }
    public static write_buf write_buf(MemorySegment segment, Arena scope) {
        return write_buf.ofAddress(write_buf$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*read_buf)(char*,struct fuse_bufvec**,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public interface read_buf {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, long _x2, long _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(read_buf fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$30.const$2, fi, constants$17.const$3, scope);
        }
        static read_buf ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, long __x2, long __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)constants$17.const$5.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle read_buf$VH() {
        return constants$30.const$3;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*read_buf)(char*,struct fuse_bufvec**,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment read_buf$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$30.const$3.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*read_buf)(char*,struct fuse_bufvec**,size_t,off_t,struct fuse_file_info*);
     * }
     */
    public static void read_buf$set(MemorySegment seg, MemorySegment x) {
        constants$30.const$3.set(seg, x);
    }
    public static MemorySegment read_buf$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$30.const$3.get(seg.asSlice(index*sizeof()));
    }
    public static void read_buf$set(MemorySegment seg, long index, MemorySegment x) {
        constants$30.const$3.set(seg.asSlice(index*sizeof()), x);
    }
    public static read_buf read_buf(MemorySegment segment, Arena scope) {
        return read_buf.ofAddress(read_buf$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*flock)(char*,struct fuse_file_info*,int);
     * }
     */
    public interface flock {

        int apply(java.lang.foreign.MemorySegment _x0, java.lang.foreign.MemorySegment _x1, int _x2);
        static MemorySegment allocate(flock fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$30.const$5, fi, constants$30.const$4, scope);
        }
        static flock ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, java.lang.foreign.MemorySegment __x1, int __x2) -> {
                try {
                    return (int)constants$31.const$0.invokeExact(symbol, __x0, __x1, __x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle flock$VH() {
        return constants$31.const$1;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*flock)(char*,struct fuse_file_info*,int);
     * }
     */
    public static MemorySegment flock$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$31.const$1.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*flock)(char*,struct fuse_file_info*,int);
     * }
     */
    public static void flock$set(MemorySegment seg, MemorySegment x) {
        constants$31.const$1.set(seg, x);
    }
    public static MemorySegment flock$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$31.const$1.get(seg.asSlice(index*sizeof()));
    }
    public static void flock$set(MemorySegment seg, long index, MemorySegment x) {
        constants$31.const$1.set(seg.asSlice(index*sizeof()), x);
    }
    public static flock flock(MemorySegment segment, Arena scope) {
        return flock.ofAddress(flock$get(segment), scope);
    }
    /**
     * {@snippet :
 * int (*fallocate)(char*,int,off_t,off_t,struct fuse_file_info*);
     * }
     */
    public interface fallocate {

        int apply(java.lang.foreign.MemorySegment _x0, int _x1, long _x2, long _x3, java.lang.foreign.MemorySegment _x4);
        static MemorySegment allocate(fallocate fi, Arena scope) {
            return RuntimeHelper.upcallStub(constants$31.const$3, fi, constants$31.const$2, scope);
        }
        static fallocate ofAddress(MemorySegment addr, Arena arena) {
            MemorySegment symbol = addr.reinterpret(arena, null);
            return (java.lang.foreign.MemorySegment __x0, int __x1, long __x2, long __x3, java.lang.foreign.MemorySegment __x4) -> {
                try {
                    return (int)constants$31.const$4.invokeExact(symbol, __x0, __x1, __x2, __x3, __x4);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    public static VarHandle fallocate$VH() {
        return constants$31.const$5;
    }
    /**
     * Getter for field:
     * {@snippet :
     * int (*fallocate)(char*,int,off_t,off_t,struct fuse_file_info*);
     * }
     */
    public static MemorySegment fallocate$get(MemorySegment seg) {
        return (java.lang.foreign.MemorySegment)constants$31.const$5.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * int (*fallocate)(char*,int,off_t,off_t,struct fuse_file_info*);
     * }
     */
    public static void fallocate$set(MemorySegment seg, MemorySegment x) {
        constants$31.const$5.set(seg, x);
    }
    public static MemorySegment fallocate$get(MemorySegment seg, long index) {
        return (java.lang.foreign.MemorySegment)constants$31.const$5.get(seg.asSlice(index*sizeof()));
    }
    public static void fallocate$set(MemorySegment seg, long index, MemorySegment x) {
        constants$31.const$5.set(seg.asSlice(index*sizeof()), x);
    }
    public static fallocate fallocate(MemorySegment segment, Arena scope) {
        return fallocate.ofAddress(fallocate$get(segment), scope);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemorySegment addr, Arena scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


